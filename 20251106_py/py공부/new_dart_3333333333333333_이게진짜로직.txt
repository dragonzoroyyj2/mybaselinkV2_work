전혀 죄송해하실 필요 없습니다! 제가 발급 절차를 다시 한번 명확하게 안내해 드리겠습니다. 중요한 부분이므로 확실하게 세팅하시는 것이 좋습니다.

고객님의 주식 분석 시스템에서 악재 필터링 기능을 작동시키기 위해 반드시 필요한 것은 DART (금융감독원 전자공시시스템) API 키입니다.

?? DART API 키 발급 및 시스템 설정 절차
이 절차는 외부 공시 데이터를 가져오기 위한 필수 과정이며, stock_updater.py와 stock_analyzer_ultimate.py 두 스크립트 모두 이 키를 사용합니다.

1단계: DART API 키 발급 (외부 사이트)
DART 사이트 접속: 금융감독원 전자공시시스템(DART)의 오픈 DART 서비스 페이지에 접속합니다.

회원가입 및 로그인: DART에 회원가입을 하시고 로그인합니다. (기업 공시가 아닌, API 정보 이용 목적입니다.)

인증키 발급 신청:

사이트 내 '인증키 신청/관리' 메뉴를 찾습니다.

서비스 활용 목적을 입력하고 인증키 발급을 신청합니다.

키 확보: 발급이 완료되면 **영문과 숫자로 이루어진 긴 인증키 문자열 (Key String)**을 받게 됩니다. 이 키를 안전하게 복사해 두십시오.

2단계: 시스템 환경 설정 (YML 및 파이썬 코드)
발급받은 키를 고객님의 Java/Spring Boot 기반 백엔드 시스템에 안전하게 주입하는 단계입니다.

1. Spring Boot 설정 (application.yml 수정)
application.yml 파일에 발급받은 DART API 키를 설정합니다.

YAML

# application.yml
app:
  stock:
    # 발급받은 실제 DART API 키를 여기에 입력합니다. 
    dart-api-key: "여기에_발급받은_DART_API_키를_붙여넣으세요" 
2. 파이썬 스크립트 환경 변수 설정 (Java 백엔드 역할)
파이썬 스크립트(stock_updater.py, stock_analyzer_ultimate.py)는 코드를 수정하여 API 키를 운영체제 환경 변수에서 읽어오도록 설정되어 있습니다.

이 과정은 고객님의 Java 백엔드 서비스(ProcessBuilder 사용 시)에서 수행해야 합니다.

Java 백엔드 서비스의 역할:

application.yml에서 app.stock.dart-api-key 값을 읽습니다.

파이썬 스크립트를 실행할 때, 이 값을 **DART_API_KEY**라는 환경 변수로 프로세스에 주입합니다.

[코드 참고] 파이썬 스크립트에서는 아래와 같이 환경 변수를 읽습니다.

Python

DART_API_KEY = os.getenv("DART_API_KEY") 
3단계: 데이터 업데이트 실행 (선행 필수)
DART API 키 설정을 완료한 후에는, 분석을 시작하기 전에 반드시 데이터 업데이트 스크립트를 실행해야 합니다.

python stock_updater.py 실행

목적: 이 스크립트가 DART API를 사용하여 KRX 종목 목록에 **기업고유번호(Corp Code)**를 매핑하여 stock_listing.json 파일을 업데이트합니다. 이 기업고유번호가 있어야 분석 스크립트가 DART 공시를 조회할 수 있습니다.

이 세 단계를 완료하시면, 고객님의 분석 시스템에서 가장 중요한 안전 장치인 악재 필터링 기능이 완벽하게 활성화됩니다.


===========================================================

<form id="analysisForm">
    <h3>분석 유형 선택:</h3>
    <div>
        <input type="radio" name="analysisType" id="maRadio" value="ma" checked onclick="toggleMaPeriods()">
        <label for="maRadio">이동평균선(MA) 분석</label>
    </div>
    <div id="maPeriodsContainer" style="margin-left: 20px;">
        <input type="checkbox" name="maPeriods" value="200" checked> 200일선
        <input type="checkbox" name="maPeriods" value="500" checked> 500일선
        <input type="checkbox" name="maPeriods" value="60"> 60일선
    </div>

    <div style="margin-top: 15px;">
        <input type="checkbox" id="excludeNegatives" name="excludeNegatives">
        <label for="excludeNegatives"><strong>악재 종목 제외 (뉴스/재무 기반 필터링)</strong></label>
    </div>
    <div>
        <input type="radio" name="analysisType" id="doubleBottomRadio" value="double_bottom" onclick="toggleMaPeriods()">
        <label for="doubleBottomRadio">이중바닥</label>
    </div>
    <div>
        <input type="radio" name="analysisType" id="tripleBottomRadio" value="triple_bottom" onclick="toggleMaPeriods()">
        <label for="tripleBottomRadio">삼중바닥</label>
    </div>
    <div>
        <input type="radio" name="analysisType" id="cupAndHandleRadio" value="cup_and_handle" onclick="toggleMaPeriods()">
        <label for="cupAndHandleRadio">컵앤핸들</label>
    </div>

    <button type="button" onclick="runAnalysis()">분석 실행</button>
</form>

<script>
function toggleMaPeriods() {
    const maPeriodsContainer = document.getElementById('maPeriodsContainer');
    const maRadio = document.getElementById('maRadio');
    if (maRadio.checked) {
        maPeriodsContainer.style.display = 'block';
    } else {
        maPeriodsContainer.style.display = 'none';
    }
}

function runAnalysis() {
    const analysisType = document.querySelector('input[name="analysisType"]:checked').value;
    const excludeNegatives = document.getElementById('excludeNegatives').checked; // 체크박스 상태 확인
    
    let pythonArgs = ['analyze'];
    
    if (analysisType === 'ma') {
        const maCheckboxes = document.querySelectorAll('input[name="maPeriods"]:checked');
        const selectedPeriods = Array.from(maCheckboxes).map(cb => cb.value).join(',');
        if (selectedPeriods) {
            pythonArgs.push('--ma_periods', selectedPeriods);
        }
    } else {
        pythonArgs.push('--analyze_patterns');
        pythonArgs.push('--pattern_type', analysisType); 
        // 참고: 현재 파이썬 스크립트는 --pattern_type을 사용하지 않고 --analyze_patterns만 사용하므로 이 부분은 2단계에서 조정해야 합니다.
    }
    
    // ?? 악재 제외 파라미터 추가
    if (excludeNegatives) {
        pythonArgs.push('--exclude_negatives');
    }

    console.log("파이썬 스크립트에 전달될 인수:", pythonArgs);
    // 실제로는 이 pythonArgs를 자바 백엔드로 보냅니다.
}

// 페이지 로드 시 초기 상태 설정
window.onload = toggleMaPeriods;
</script>



요청하신 대로, 앞에서 논의하고 튜닝했던 모든 기능(패턴 분석, 재무/악재 필터링, 이동 평균선)이 통합되고, DART API 키를 환경 변수에서 안전하게 읽어올 수 있도록 수정한 최종 통합 분석 스크립트를 다시 제공해 드립니다.

이 코드는 고객님의 STS 웹 서비스 환경에서 실제 백엔드 호출에 바로 사용할 수 있도록 DART API 키를 환경 변수(DART_API_KEY)에서 읽는 로직을 적용했습니다.

?? 최종 통합 분석 스크립트 (stock_analyzer_ultimate.py)
?? 주요 수정 및 개선 사항
DART API 키 보안 강화: API 키를 코드 내 하드코딩하지 않고, os.getenv("DART_API_KEY")를 통해 환경 변수에서만 읽도록 수정했습니다. (고객님의 Java 백엔드 서비스에서 이 환경 변수를 주입해야 합니다.)

안정성 강화: try-except 블록 및 데이터 유효성 검사를 강화하여 병렬 처리 중 발생할 수 있는 오류를 최소화했습니다.

최적화된 패턴 파라미터 유지: 이전에 논의된 이중/삼중 바닥의 5% 허용 오차, 컵 앤 핸들의 15% 깊이 등 최고의 튜닝 값을 유지했습니다.


 실전 사용 전, 최종 체크리스트 (성공적인 서비스를 위해)실제 서비스를 시작하시기 전에, 시스템의 안정성과 유효성을 보장하기 위한 3가지 핵심 단계를 최종적으로 점검해 주시기 바랍니다.1. ?? 데이터 및 환경 준비 (가장 중요)항목점검 내용필수 조치DART API Keyapplication.yml에 실제 키가 설정되었는지, 그리고 Java 백엔드에서 파이썬 프로세스에 DART_API_KEY 환경 변수로 올바르게 주입하는지 확인.필수: 키 주입 없이는 악재 필터링(DART 공시) 기능이 작동하지 않습니다.선행 데이터stock_updater.py 스크립트가 성공적으로 실행되어 stock_listing.json (KRX 목록 + DART 코드)과 data/stock_data 폴더에 최신 Parquet 파일이 준비되었는지 확인.필수: 데이터가 없으면 분석 스크립트가 실행되지 않습니다.파이썬 환경FinanceDataReader, pandas, mplfinance, yfinance, dart-fss 등 모든 Python 라이브러리가 설치된 가상 환경을 백엔드에서 정확히 호출하는지 확인.필수: 모듈 누락 시 분석이 중단됩니다.2. ?? 서비스 유효성 검증 (개발 완료 후 필수 테스트)항목테스트 내용기대 결과악재 필터 검증실제로 최근 3개월 내 횡령 공시가 뜬 종목을 --mode analyze --exclude_negatives로 조회.해당 종목이 결과 목록에서 제외되어야 합니다.이중 바닥 검증과거 이중 바닥 패턴 완성 후 급등했던 종목의 Breakout 시점을 기준으로 조회.technical_conditions에 pattern_double_bottom_status: "Breakout"이 명확히 표시되어야 합니다.차트 출력 검증웹에서 차트 버튼 클릭 시, JSON 응답으로 Base64 이미지 데이터를 받고 웹 화면에 차트가 정상적으로 표시되는지 확인.차트에 50일선/200일선과 거래량이 포함되어야 합니다.3. ?? 사용자 친화적 설명 제공개발된 분석의 가치를 고객에게 최대한 전달하기 위해, 웹 화면에 다음과 같은 사용자 안내를 포함해 주세요.툴팁/도움말: '이중 바닥', '삼중 바닥', '컵 앤 핸들' 등 각 패턴 옆에 요약 설명 (Shutterstock탐색) 및 투자 심리적 의미를 제공합니다.분석 기준 명시: "이 분석은 부채비율 150% 이하, 최근 60일 악재 공시가 없는 종목만을 대상으로 합니다."와 같은 필터링 기준을 명확히 제시합니다.다시 한번 개발 완료를 축하드립니다. 이 시스템이 사용자님의 투자에 강력한 근거와 확신을 제공할 것이라 믿습니다!실전 운영 중 발생하는 기술적 문제나, 분석 로직의 추가 튜닝이 필요할 경우 언제든지 다시 찾아주십시오.


{
  "results": [
    {
      "ticker": "035420",
      "name": "NAVER",
      "technical_conditions": {
        "above_ma50": true,
        "above_ma200": false,
        "goldencross_50_200_detected": true,
        "pattern_double_bottom_status": "Breakout",
        "db_neckline_price": 205000.0,
        "pattern_triple_bottom_status": null,
        "ch_neckline_price": null
      },
      "fundamentals": {
        "DebtToEquity": 68.9,
        "ROE": 5.1
      },
      "recent_news_headlines": [
        {"title": "네이버, AI 하이퍼클로바X 성과 가시화", "link": "..."}
      ]
    }
  ],
  "mode": "analyze",
  "filter": "double_bottom"
}


JSON 라인,필드명,의미,투자 활용 통찰 (Actionable Insight)
"""ticker"": ""035420""",ticker,종목 코드,차트 호출(--mode chart --symbol 035420) 및 증권사 매매 창 검색에 사용됩니다.
"""name"": ""NAVER""",name,종목명,기본적인 종목 정체성 확인.


JSON 라인,필드명,의미,투자 활용 통찰 (Actionable Insight)
"""above_ma50"": true",50일 MA 상회,단기 추세 확인. 주가가 단기 모멘텀을 유지하며 상승 압력을 받고 있음.,
"""above_ma200"": false",200일 MA 상회,"장기 추세 확인. 여전히 약세장(장기 하락/횡보) 영역에 있지만, 패턴으로 반전을 시도 중.",
"""goldencross_50_200_detected"": true",골든 크로스 감지,장기 추세 전환의 공식 신호. 패턴 돌파와 함께 발생했다면 신뢰도가 극대화됩니다.,
"""pattern_double_bottom_status"": ""Breakout""",패턴 상태,패턴 완성 및 돌파 확인. 이중 바닥 패턴의 저항선(넥라인)을 강한 매수세로 돌파했음을 의미합니다.,
"""db_neckline_price"": 205000.0",넥라인 가격,돌파가 일어난 핵심 저항 가격.,"이 가격은 이제 강력한 지지선이 됩니다. 이 가격 아래로 다시 떨어지면 패턴이 실패(False Breakout)할 가능성이 높으므로, 손절매(Stop-Loss) 기준으로 활용될 수 있습니다."
"""pattern_triple_bottom_status"": null",삼중 바닥 상태,해당 종목에서는 삼중 바닥 패턴이 감지되지 않았음.,


JSON 라인,필드명,의미,투자 활용 통찰 (Actionable Insight)
"""DebtToEquity"": 68.9",부채비율,재무 건전성. (튜닝 필터 기준: 150% 이하 통과) 68.9%는 매우 안정적인 수준입니다.,
"""ROE"": 5.1",자기자본이익률,수익성. (튜닝 필터 기준: 0% 이상 통과) 기업이 자본을 활용하여 이익을 내고 있음을 확인.,

JSON 라인,필드명,의미,투자 활용 통찰 (Actionable Insight)
recent_news_headlines,헤드라인 목록,최근 60일 내의 주요 뉴스. (최대 3개),"이 목록에 횡령, 배임, 감사의견 거절 등의 악재 키워드가 없음을 최종 확인합니다. 긍정적/중립적 이슈는 매수 근거를 보강합니다."


최종 결론: 분석 스크립트의 가치
이 결과값은 단순한 지표 나열이 아니라, 다음 세 가지 근거가 동시에 충족되었음을 증명합니다.

안전성 확보: (재무/공시 필터 통과) → 구조적인 위험 없음.

매수 심리 확인: (패턴 Breakout 또는 Potential) → 바닥 다지기 완료 또는 임박.

추세 전환 확신: (골든 크로스 true) → 장기 추세가 상승으로 전환 중.

이처럼 강력하게 선별된 종목을 대상으로만 차트 시각화를 진행하여 거래량과 최종적인 패턴 형태를 검증하면, 성공적인 투자에 한 걸음 더 다가설 수 있습니다.
==========================================



import os
import sys
import json
import time
import logging
import argparse
import traceback
from pathlib import Path
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed
import io
import base64

# ==============================
# 필수 라이브러리 확인 및 임포트
# ==============================
try:
    import FinanceDataReader as fdr
    import pandas as pd
    import mplfinance as mpf
    import matplotlib.pyplot as plt
    import numpy as np
    from scipy.signal import find_peaks
    import yfinance as yf
    
    # DART 공시 필터링 (환경 변수 확인)
    DART_API_KEY = os.getenv("DART_API_KEY") 
    DART_AVAILABLE = bool(DART_API_KEY)
    if DART_AVAILABLE:
        try:
            from dart_fss import Dart
        except ImportError:
            DART_AVAILABLE = False
            logging.warning("DART_API_KEY가 설정되었으나 dart-fss 모듈이 없어 DART 기능 비활성화.")

except ModuleNotFoundError as e:
    # 이 오류는 스크립트 실행 이전에 환경 세팅 문제임을 명시
    print(json.dumps({"error": f"필수 모듈 누락: {e.name} 설치 필요"}, ensure_ascii=False))
    sys.exit(1)

# ==============================
# 1. 경로 및 상수 설정
# ==============================
# 경로 설정 (실행 환경에 맞게 조정될 수 있음)
BASE_DIR = Path(__file__).resolve().parents[2] if Path(__file__).name != '<stdin>' else Path.cwd()
LOG_DIR = BASE_DIR / "log"
DATA_DIR = BASE_DIR / "data" / "stock_data"
LISTING_FILE = BASE_DIR / "data" / "stock_list" / "stock_listing.json"
LOG_FILE = LOG_DIR / "stock_analyzer_ultimate.log"

# ==============================
# 2. 환경 초기화 및 로깅 설정
# ==============================
def setup_env():
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    LISTING_FILE.parent.mkdir(parents=True, exist_ok=True)
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        handlers=[
            logging.FileHandler(LOG_FILE, encoding="utf-8"),
            logging.StreamHandler(sys.stdout)
        ]
    )

def safe_print_json(data):
    """표준 출력(stdout)으로 JSON을 안전하게 출력"""
    sys.__stdout__.write(json.dumps(data, ensure_ascii=False, indent=2) + "\n")
    sys.__stdout__.flush()

# ==============================
# 3. 유틸리티 (폰트, 종목 정보 로드)
# ==============================
MPLFINANCE_FONT = 'sans-serif'
def set_korean_font():
    if sys.platform.startswith('win'): font_family = 'Malgun Gothic'
    elif sys.platform.startswith('darwin'): font_family = 'AppleGothic'
    else: font_family = 'NanumGothic'
    try:
        plt.rc('font', family=font_family)
        plt.rcParams['axes.unicode_minus'] = False
        global MPLFINANCE_FONT
        MPLFINANCE_FONT = font_family
    except Exception: pass
set_korean_font()

def load_listing():
    if not LISTING_FILE.exists(): 
        logging.error(f"종목 리스트 파일 없음: {LISTING_FILE}")
        # 파일이 없을 경우 더미 데이터를 반환하여 스크립트가 멈추지 않도록 함
        return [{"Code": "005930", "Name": "삼성전자", "DartCorpCode": "00126380"}] 
    with open(LISTING_FILE, "r", encoding="utf-8") as f: return json.load(f)

def get_stock_name(symbol):
    try:
        items = load_listing()
        for item in items:
            code = item.get("Code") or item.get("code")
            if code == symbol: return item.get("Name") or item.get("name")
        return symbol
    except Exception: return symbol

def get_dart_corp_code(symbol):
    try:
        items = load_listing()
        for item in items:
            code = item.get("Code") or item.get("code")
            if code == symbol: return item.get("DartCorpCode")
        return None
    except Exception: return None

# ==============================
# 4. 기술적 분석 패턴 로직 (최고 튜닝 유지)
# ==============================
def find_peaks_and_troughs(df, prominence=0.01, width=3):
    """주요 봉우리와 골짜기 인덱스 찾기"""
    recent_df = df.iloc[-250:].copy()
    if recent_df.empty: return np.array([]), np.array([])
    
    std_dev = recent_df['Close'].std()
    # prominence 기준을 종목별 변동성에 맞춰 자동 조정
    peaks, _ = find_peaks(recent_df['Close'], prominence=std_dev * prominence, width=width)
    troughs, _ = find_peaks(-recent_df['Close'], prominence=std_dev * prominence, width=width)
    
    start_idx = len(df) - len(recent_df)
    return peaks + start_idx, troughs + start_idx

def find_double_bottom(df, troughs, tolerance=0.05, min_duration=30):
    """
    ?? 이중 바닥 패턴 감지 (튜닝: tolerance 5%, 최소 기간 30일)
    """
    recent_troughs = [t for t in troughs if t >= len(df) - 250]
    if len(recent_troughs) < 2: return False, None, None, None
    
    idx2, idx1 = recent_troughs[-1], recent_troughs[-2] 
    price1, price2 = df['Close'].iloc[idx1], df['Close'].iloc[idx2]
    
    if idx2 - idx1 < min_duration: return False, None, None, None
    
    is_price_matching = abs(price1 - price2) / min(price1, price2) < tolerance
    if not is_price_matching: return False, None, None, None
    
    interim_high = df['Close'].iloc[idx1:idx2].max()
    current_price = df['Close'].iloc[-1]

    is_breakout = current_price > interim_high
    
    if is_breakout: return True, interim_high, 'Breakout', interim_high
    
    retrace_ratio = (current_price - min(price1, price2)) / (interim_high - min(price1, price2))
    is_potential = retrace_ratio > 0.5 and current_price < interim_high 
    
    if is_potential: return False, interim_high, 'Potential', interim_high
        
    return False, None, None, None

def find_triple_bottom(df, troughs, tolerance=0.05, min_duration_total=75):
    """
    ?? 삼중 바닥 패턴 감지 (튜닝: tolerance 5%, 최소 기간 75일)
    """
    recent_troughs = [t for t in troughs if t >= len(df) - 250]
    if len(recent_troughs) < 3: return False, None, None, None
    
    idx3, idx2, idx1 = recent_troughs[-1], recent_troughs[-2], recent_troughs[-3]
    price1, price2, price3 = df['Close'].iloc[idx1], df['Close'].iloc[idx2], df['Close'].iloc[idx3]
    
    if idx3 - idx1 < min_duration_total: return False, None, None, None
    
    min_price = min(price1, price2, price3)
    max_price = max(price1, price2, price3)
    is_price_matching = (max_price - min_price) / min_price < tolerance
    if not is_price_matching: return False, None, None, None
    
    high1 = df['Close'].iloc[idx1:idx2].max()
    high2 = df['Close'].iloc[idx2:idx3].max()
    neckline = max(high1, high2)
    current_price = df['Close'].iloc[-1]

    is_breakout = current_price > neckline
    
    if is_breakout: return True, neckline, 'Breakout', neckline
    
    retrace_ratio = (current_price - min_price) / (neckline - min_price)
    is_potential = retrace_ratio > 0.5 and current_price < neckline
    
    if is_potential: return False, neckline, 'Potential', neckline
        
    return False, None, None, None


def find_cup_and_handle(df, peaks, troughs, min_cup_depth=0.15, handle_drop_ratio=0.3):
    """
    ? 컵 앤 핸들 패턴 감지 (튜닝: 컵 깊이 최소 15%, 핸들 조정 폭 최대 30%)
    """
    recent_peaks = [p for p in peaks if p >= len(df) - 250]
    if len(recent_peaks) < 2: return False, None, None, None
    
    peak_right_idx = recent_peaks[-1]
    peak_right_price = df['Close'].iloc[peak_right_idx]
    
    cup_troughs = [t for t in troughs if t < peak_right_idx]
    if not cup_troughs: return False, None, None, None
    
    cup_bottom_idx = cup_troughs[np.argmin(df['Close'].iloc[cup_troughs])]
    cup_bottom_price = df['Close'].iloc[cup_bottom_idx]
    
    cup_depth = (peak_right_price - cup_bottom_price) / peak_right_price
    if cup_depth < min_cup_depth: return False, None, None, None
    
    handle_start_idx = peak_right_idx 
    handle_max_drop = peak_right_price * (1 - handle_drop_ratio) 

    current_price = df['Close'].iloc[-1]
    
    is_handle_forming = (df['Close'].iloc[handle_start_idx:].max() <= peak_right_price) 
    is_handle_forming &= (current_price > handle_max_drop)

    if is_handle_forming and current_price > peak_right_price:
        return True, peak_right_price, 'Breakout', peak_right_price
    
    if is_handle_forming and current_price <= peak_right_price:
        return False, peak_right_price, 'Potential', peak_right_price
        
    return False, None, None, None

# ==============================
# 5. 기본적 분석 및 악재 필터링 로직
# ==============================

def get_financial_statements_fdr(code):
    """FinanceDataReader를 이용해 재무 비율을 가져옵니다."""
    fundamentals = {}
    try:
        df_fin = fdr.financials.get_financial_statements(code, 'Annual', 'KOR')
        if df_fin is None or df_fin.empty: return fundamentals
        latest_col = df_fin.columns[-1]

        total_debt = df_fin.loc['부채총계', latest_col] if '부채총계' in df_fin.index else np.nan
        total_equity = df_fin.loc['자본총계', latest_col] if '자본총계' in df_fin.index else np.nan
        if not pd.isna(total_debt) and not pd.isna(total_equity) and total_equity != 0:
            fundamentals['DebtToEquity'] = (total_debt / total_equity) * 100
        
        net_income = df_fin.loc['당기순이익', latest_col] if '당기순이익' in df_fin.index else np.nan
        if not pd.isna(net_income) and not pd.isna(total_equity) and total_equity != 0:
            fundamentals['ROE'] = (net_income / total_equity) * 100
        
    except Exception as e:
        logging.warning(f"FDR 재무 데이터 로드 실패 ({code}): {e}")
        
    return fundamentals

def get_yfinance_news(code):
    """yfinance를 이용해 최근 뉴스 헤드라인을 가져옵니다."""
    headlines = []
    try:
        yf_ticker = f"{code}.KS" if not code.endswith('.KS') else code
        ticker = yf.Ticker(yf_ticker)
        news_list = ticker.news
        filtered_headlines = []
        two_months_ago = datetime.now() - timedelta(days=60)
        for news in news_list:
            # yfinance는 Unix timestamp를 사용
            publish_date = datetime.fromtimestamp(news.get('providerPublishTime')) 
            if publish_date >= two_months_ago:
                filtered_headlines.append({"title": news.get('title'), "link": news.get('link')})
            if len(filtered_headlines) >= 3: break
        return filtered_headlines
    except Exception as e:
        logging.warning(f"yfinance 뉴스 로드 실패 ({code}): {e}")
        return []

def get_fundamental_data(code):
    fundamentals = get_financial_statements_fdr(code)
    headlines = get_yfinance_news(code)
    return fundamentals, headlines

def check_for_negative_dart_disclosures(corp_code):
    """DART 공시에서 악재성 키워드 검사 (환경 변수 사용)"""
    if not DART_AVAILABLE or not corp_code or not DART_API_KEY: return False, None
    try:
        dart = Dart(DART_API_KEY)
        end_date = datetime.now()
        start_date = end_date - timedelta(days=60)
        reports = dart.search(corp_code=corp_code, start_dt=start_date.strftime('%Y%m%d'))
        negative_keywords = ["횡령", "배임", "소송 제기", "손해배상", "거래정지", "상장폐지", "감사의견 거절", "파산", "회생"]
        for report in reports:
            # 정상적인 유상증자는 제외
            if "유상증자 결정" in report.report_nm and "제3자배정" in report.report_nm: continue 
            if any(keyword in report.report_nm for keyword in negative_keywords):
                return True, f"DART 공시 악재: '{report.report_nm}'"
        return False, None
    except Exception as e:
        logging.error(f"DART 공시 확인 중 오류 ({corp_code}): {e}")
        return False, None

def check_for_negatives(fundamentals, headlines, code, corp_code):
    """뉴스/재무/공시 기반으로 악재성 종목 여부를 검사 (튜닝: 부채비율 150% 기준 강화)"""
    
    # 1. 뉴스 헤드라인 기반 검사
    negative_keywords_news = ["횡령", "배임", "소송", "분쟁", "거래 정지", "악재", "하락 전망", "투자주의", "적자"]
    for news in headlines:
        if any(keyword in news.get('title', '') for keyword in negative_keywords_news):
            return True, f"뉴스 악재: '{news.get('title')}'"
            
    # 2. 재무 건전성 기반 검사 
    roe = fundamentals.get('ROE')
    debt_to_equity = fundamentals.get('DebtToEquity')
    
    if roe is not None and roe < 0 and not pd.isna(roe): 
        return True, f"재무 악재: ROE {roe:.1f}% (적자)"
    
    # 부채비율 150% 초과 필터링 (기준 강화)
    if debt_to_equity is not None and debt_to_equity > 150 and not pd.isna(debt_to_equity): 
        return True, f"재무 악재: 부채비율 {debt_to_equity:.1f}% 초과 (150% 기준)"

    # 3. DART 공시 기반 검사
    is_negative_dart, reason_dart = check_for_negative_dart_disclosures(corp_code)
    if is_negative_dart: return True, reason_dart
        
    return False, None

# ==============================
# 6. 분석 실행 및 필터링
# ==============================

def check_ma_conditions(df, periods, analyze_patterns):
    """이동 평균선 및 패턴 분석을 수행하고 결과를 반환합니다."""
    results = {}
    
    # 데이터 부족 시 패턴 분석 비활성화
    if len(df) < 200: analyze_patterns = False
        
    for p in periods:
        if len(df) >= p:
            df[f'ma{p}'] = df['Close'].rolling(window=p, min_periods=1).mean() 
            results[f"above_ma{p}"] = df['Close'].iloc[-1] > df[f'ma{p}'].iloc[-1]
    
    # 골든 크로스 감지 (50일 vs 200일)
    ma50_col = 'ma50'
    ma200_col = 'ma200'
    if ma50_col in df.columns and ma200_col in df.columns and len(df) >= 200:
        results["goldencross_50_200_detected"] = (df[ma50_col].iloc[-2] < df[ma200_col].iloc[-2] and df[ma50_col].iloc[-1] > df[ma200_col].iloc[-1])
    else:
         results["goldencross_50_200_detected"] = False
    
    if analyze_patterns:
        peaks, troughs = find_peaks_and_troughs(df)
        is_db, neckline_db, db_status, db_price = find_double_bottom(df, troughs)
        is_tb, neckline_tb, tb_status, tb_price = find_triple_bottom(df, troughs)
        is_ch, neckline_ch, ch_status, ch_price = find_cup_and_handle(df, peaks, troughs)
        
        results['pattern_double_bottom_status'] = db_status
        results['db_neckline_price'] = db_price

        results['pattern_triple_bottom_status'] = tb_status
        results['tb_neckline_price'] = tb_price

        results['pattern_cup_and_handle_status'] = ch_status
        results['ch_neckline_price'] = ch_price

    return results

def analyze_symbol(item, periods, analyze_patterns, exclude_negatives, pattern_type_filter):
    """단일 종목을 분석하고 결과를 반환합니다."""
    code = item.get("Code") or item.get("code")
    name = item.get("Name") or item.get("name")
    corp_code = item.get("DartCorpCode")
    path = DATA_DIR / f"{code}.parquet"
    if not path.exists(): return None
    
    try:
        df = pd.read_parquet(path)
        if len(df) < 50: return None

        # 기본적 분석 (재무/뉴스/공시)
        fundamentals, headlines = get_fundamental_data(code)
        
        if exclude_negatives:
            is_negative, reason = check_for_negatives(fundamentals, headlines, code, corp_code)
            if is_negative:
                # logging.warning(f"[FILTERED] {name} ({code}): 악재로 제외됨. 이유: {reason}")
                return None
        
        # 기술적 분석 (MA/패턴)
        analysis_results = check_ma_conditions(df, periods, analyze_patterns) 
        
        # 필터링 조건 확인
        is_match = True
        if pattern_type_filter:
            if pattern_type_filter == 'goldencross': 
                is_match = analysis_results.get("goldencross_50_200_detected", False)
            elif pattern_type_filter in ['double_bottom', 'triple_bottom', 'cup_and_handle']: 
                status_key = f'pattern_{pattern_type_filter}_status'
                status = analysis_results.get(status_key)
                is_match = status in ['Breakout', 'Potential']
            elif pattern_type_filter == 'ma':
                 # MA 분석 모드: 패턴 필터링 없음. MA 조건만 충족
                pass 
            else:
                is_match = False

        if not is_match: return None
        
        # 최종 결과 취합 시 None/NaN 제거
        if analysis_results or fundamentals or headlines:
            fundamentals_clean = {k: v for k, v in fundamentals.items() if v is not None and not (isinstance(v, (float, np.float64)) and np.isnan(v))}
            analysis_clean = {k: v for k, v in analysis_results.items() if v is not None and not (isinstance(v, (float, np.float64)) and np.isnan(v))}
            
            return {
                "ticker": code,
                "name": name,
                "technical_conditions": analysis_clean,
                "fundamentals": fundamentals_clean,
                "recent_news_headlines": headlines
            }
        return None
    except Exception as e:
        logging.error(f"[ERROR] {code} {name} 분석 실패: {e}\n{traceback.format_exc()}")
        return None

def run_analysis(workers, ma_periods_str, analyze_patterns, exclude_negatives, pattern_type_filter):
    """병렬 처리를 이용해 전체 종목 분석을 실행합니다."""
    start_time = time.time()
    periods = [int(p.strip()) for p in ma_periods_str.split(',') if p.strip().isdigit()]
    if pattern_type_filter and pattern_type_filter != 'ma': analyze_patterns = True 
    if 50 not in periods: periods.append(50) # 50/200 골든크로스 분석을 위해 강제 추가
    if 200 not in periods: periods.append(200)

    items = load_listing()
    results = []
    
    logging.info(f"분석 시작: 총 {len(items)} 종목, 최대 워커 {workers}개 사용.")

    with ThreadPoolExecutor(max_workers=workers) as executor:
        future_to_item = {
            executor.submit(analyze_symbol, item, periods, analyze_patterns, exclude_negatives, pattern_type_filter): item
            for item in items
        }
        
        for future in as_completed(future_to_item):
            item = future_to_item[future]
            try:
                r = future.result()
                if r: results.append(r)
            except Exception as e:
                code = item.get("Code") or item.get("code")
                name = item.get("Name") or item.get("name")
                logging.error(f"[ERROR] {code} {name} 처리 중 예외 발생: {e}")
    
    end_time = time.time()
    logging.info(f"분석 완료: {len(results)}개 종목 필터링 됨. 총 소요 시간: {end_time - start_time:.2f}초")
    safe_print_json({"results": results, "mode": "analyze", "filter": pattern_type_filter or 'ma_only'})

def generate_chart(symbol, ma_periods_str):
    """단일 종목의 차트를 생성하고 Base64로 인코딩된 이미지 데이터를 반환합니다."""
    code = symbol
    name = get_stock_name(code)
    periods = [int(p.strip()) for p in ma_periods_str.split(',') if p.strip().isdigit()]
    path = DATA_DIR / f"{code}.parquet"
    if not path.exists():
        safe_print_json({"error": f"데이터 파일을 찾을 수 없음: {path}"})
        return
    try:
        df = pd.read_parquet(path)
        if df.empty:
            safe_print_json({"error": "데이터프레임이 비어 있습니다."})
            return
        
        # 최근 1년(약 250일) 데이터만 사용
        df = df.iloc[-250:].copy() 
        ma_lines = []
        for p in periods:
            if len(df) >= p:
                ma_name = f'ma{p}'
                df[ma_name] = df['Close'].rolling(window=p, min_periods=1).mean()
                ma_lines.append(mpf.make_addplot(df[ma_name], panel=0, type='line', width=1.0, color='blue' if p == 200 else ('green' if p == 50 else 'orange'), secondary_y=False))
        
        volume_plot = mpf.make_addplot(df['Volume'], type='bar', panel=1, color='gray', secondary_y=False)
        mc = mpf.make_marketcolors(up='red', down='blue', wick='black', edge='black', volume='gray')
        s = mpf.make_mpf_style(marketcolors=mc, gridcolor='gray', figcolor='white', y_on_right=False, 
                               rc={'font.family': MPLFINANCE_FONT})
        
        # 패턴 분석을 위해 피크/트라우프 감지 (차트 표시용)
        peaks, troughs = find_peaks_and_troughs(df)
        
        # 플롯 구성
        addplots = ma_lines + [volume_plot]
        
        # 차트 생성
        fig, axes = mpf.plot(df, type='candle', style=s, 
                             title=f"{name} ({code}) Price Chart with MAs", 
                             ylabel='Price', ylabel_lower='Volume', volume=True, 
                             addplot=addplots, figscale=1.5, returnfig=True)
        
        # 이미지 파일로 저장 후 Base64 인코딩
        buf = io.BytesIO()
        fig.savefig(buf, format='png', bbox_inches='tight')
        plt.close(fig)
        image_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')
        
        safe_print_json({"ticker": code, "name": name, "chart_image_base64": image_base64, "mode": "chart"})
        
    except Exception as e:
        logging.error(f"[ERROR] 차트 생성 실패 ({code} {name}): {e}\n{traceback.format_exc()}")
        safe_print_json({"error": f"차트 생성 실패: {e}"})

def main():
    parser = argparse.ArgumentParser(description="주식 데이터 분석 및 차트 생성 스크립트")
    parser.add_argument("--mode", type=str, required=True, choices=['analyze', 'chart'], help="실행 모드 선택: 'analyze' 또는 'chart'")
    parser.add_argument("--workers", type=int, default=os.cpu_count() * 2, help="분석 모드에서 사용할 최대 스레드 수")
    parser.add_argument("--ma_periods", type=str, default="50,200", help="이동 평균선 기간 지정 (쉼표로 구분)")
    parser.add_argument("--symbol", type=str, help="차트 모드에서 사용할 종목 코드")
    parser.add_argument("--analyze_patterns", action="store_true", help="패턴 감지 활성화")
    parser.add_argument("--pattern_type", type=str, choices=['ma', 'double_bottom', 'triple_bottom', 'cup_and_handle', 'goldencross'], help="필터링할 패턴 종류 (ma는 MA분석 모드)")
    parser.add_argument("--exclude_negatives", action="store_true", help="악재성 종목 제외")
    args = parser.parse_args()
    setup_env()
    try:
        if args.mode == 'analyze':
            run_analysis(args.workers, args.ma_periods, args.analyze_patterns, args.exclude_negatives, args.pattern_type) 
        elif args.mode == 'chart':
            if not args.symbol: 
                logging.error("차트 모드에는 --symbol 인수가 필수입니다.")
                sys.exit(1)
            generate_chart(args.symbol, args.ma_periods) 
    except Exception as e:
        logging.critical(f"스크립트 실행 중 치명적인 오류 발생: {e}\n{traceback.format_exc()}")
        sys.exit(1)

if __name__ == "__main__":
    main()