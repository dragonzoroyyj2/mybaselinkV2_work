import os
import sys
import json
import time
import logging
import argparse
import concurrent.futures
from pathlib import Path
from datetime import datetime, timedelta

# ==============================
# 필수 라이브러리 확인 및 임포트
# ==============================
try:
    import FinanceDataReader as fdr
    import pandas as pd
except ModuleNotFoundError as e:
    print(json.dumps({"error": f"필수 모듈 누락: {e.name} 설치 필요"}, ensure_ascii=False))
    sys.exit(1)

# ==============================
# 1?? 경로 설정 (사용자님의 기준 유지)
# ==============================
# 현재 파일 위치 기준 경로 설정: 상위 2단계 디렉터리를 BASE_DIR로 설정
BASE_DIR = Path(__file__).resolve().parents[2]
LOG_DIR = BASE_DIR / "log"
DATA_DIR = BASE_DIR / "data" / "stock_data"
LISTING_FILE = BASE_DIR / "data" / "stock_list" / "stock_listing.json"
LOG_FILE = LOG_DIR / "stock_updater.log"

# ==============================
# 2?? 환경 초기화 및 로깅 설정
# ==============================
def setup_env():
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    LISTING_FILE.parent.mkdir(parents=True, exist_ok=True)
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        handlers=[logging.FileHandler(LOG_FILE, encoding="utf-8"), logging.StreamHandler(sys.stdout)]
    )

def safe_print_json(data):
    sys.__stdout__.write(json.dumps(data, ensure_ascii=False, indent=2) + "\n")
    sys.__stdout__.flush()

# ==============================
# 3?? KRX 종목 목록 다운로드
# ==============================
def download_and_save_listing():
    try:
        logging.info("[PROGRESS] 5.0 KRX 종목 목록 다운로드 중...")
        krx = fdr.StockListing("KRX")
        if krx is None or krx.empty: raise ValueError("KRX 데이터 다운로드 실패")
        krx["Date"] = datetime.now().strftime("%Y-%m-%d")
        krx.to_json(LISTING_FILE, orient="records", force_ascii=False, indent=2)
        logging.info(f"[LOG] KRX 종목 리스트 저장 완료: {LISTING_FILE}")
        logging.info(f"[KRX_TOTAL] {len(krx)}")
        return krx
    except Exception as e:
        logging.error(f"[ERROR] KRX 목록 다운로드 실패: {e}")
        safe_print_json({"error": "KRX 목록 다운로드 실패", "detail": str(e)}); sys.exit(1)

# ==============================
# 4?? 개별 종목 데이터 업데이트 (증분 업데이트 로직 포함)
# ==============================
def fetch_and_save_stock(symbol: str, name: str, force: bool = False):
    file_path = DATA_DIR / f"{symbol}.parquet"
    today = datetime.now().date()
    if file_path.exists() and not force:
        try:
            df_cached = pd.read_parquet(file_path)
            last_date_in_cache = df_cached.index.max().date()
            if last_date_in_cache >= today: return f"{symbol} {name} → 최신 캐시 사용", "cached"
            start_date_for_update = last_date_in_cache + timedelta(days=1)
            df_new = fdr.DataReader(symbol, start=start_date_for_update)
            if not df_new.empty:
                df_updated = pd.concat([df_cached, df_new]).drop_duplicates()
                df_updated.to_parquet(file_path)
                return f"{symbol} {name} → 캐시 업데이트 완료", "success"
            else: return f"{symbol} {name} → 최신 데이터 없음, 캐시 사용", "no_update"
        except Exception as e:
            logging.error(f"캐시 업데이트 실패: {symbol} {name} → {e}, 전체 재다운로드 시도")
    try:
        df = fdr.DataReader(symbol)
        if df is None or df.empty: return f"{symbol} {name} → 데이터 없음", "no_data"
        df.to_parquet(file_path)
        return f"{symbol} {name} → 전체 저장 완료", "success"
    except Exception as e:
        logging.error(f"예외 발생: {symbol} {name} → {e}")
        return f"{symbol} {name} → 실패: {e}", "failed"

# ==============================
# 5?? 전체 종목 병렬 다운로드 실행
# ==============================
def run_download_stocks(krx, workers: int, force: bool):
    symbols = krx["Code"].astype(str).tolist()
    names = krx["Name"].astype(str).tolist()
    total_count = len(symbols)
    logging.info(f"[PROGRESS] 20.0 KRX 목록 {total_count}건 로드됨")
    logging.info("[PROGRESS] 30.0 개별 종목 데이터 다운로드 시작")
    update_step = max(1, total_count // 50)
    completed_count, failed_count = 0, 0
    start_time = time.time()
    MAX_TOTAL_SECONDS = 300
    PER_STOCK_TIMEOUT = 10
    with concurrent.futures.ThreadPoolExecutor(max_workers=workers) as executor:
        futures = {executor.submit(fetch_and_save_stock, sym, nm, force): (idx, sym, nm) for idx, (sym, nm) in enumerate(zip(symbols, names))}
        try:
            for future in concurrent.futures.as_completed(futures, timeout=MAX_TOTAL_SECONDS):
                idx, sym, nm = futures[future]
                try:
                    result_msg, result_type = future.result(timeout=PER_STOCK_TIMEOUT)
                    if result_type == "failed": failed_count += 1
                    completed_count += 1
                    logging.info(f"[LOG] {result_msg} ({completed_count}/{total_count})")
                    if (completed_count % update_step == 0) or (completed_count == total_count):
                        pct = 30.0 + (completed_count / total_count) * 70.0
                        logging.info(f"[PROGRESS] {pct:.1f} 종목 저장 {completed_count}/{total_count}")
                except concurrent.futures.TimeoutError:
                    failed_count += 1
                    logging.error(f"[TIMEOUT] {sym} {nm} → 응답 없음 (10초 초과 스킵)")
                except Exception as e:
                    failed_count += 1
                    logging.error(f"[ERROR] {sym} {nm} → {e}")
        except concurrent.futures.TimeoutError:
            remaining = [f for f in futures if not f.done()]
            for f in remaining: f.cancel()
            logging.error(f"[GLOBAL TIMEOUT] 전체 다운로드 제한(5분) 초과 ? 남은 {len(remaining)}개 작업 취소")
    elapsed = time.time() - start_time
    logging.info(f"[LOG] 총 소요: {elapsed:.2f}초")
    safe_print_json({"status": "completed", "mode": "update", "success": completed_count - failed_count, "failed": failed_count, "total": total_count})

# ==============================
# 6?? 메인 함수
# ==============================
def main():
    parser = argparse.ArgumentParser(description="주식 데이터 다운로드 및 업데이트 스크립트")
    parser.add_argument("--force", action="store_true", help="강제 재다운로드")
    parser.add_argument("--workers", type=int, default=8, help="병렬 처리 워커 수")
    args = parser.parse_args()
    setup_env()
    start_time = time.time()
    logging.info(f"[LOG] 실행 시작 (mode: update, force={args.force})")
    try:
        krx_listing = download_and_save_listing()
        run_download_stocks(krx_listing, args.workers, args.force)
    except Exception as e:
        logging.error(f"[ERROR] 예외 발생: {e}")
        safe_print_json({"error": str(e)}); sys.exit(1)
    finally:
        elapsed = time.time() - start_time
        logging.info(f"[LOG] 총 소요: {elapsed:.2f}초")
        logging.info("[PROGRESS] 100.0 전체 완료")

if __name__ == "__main__":
    main()
