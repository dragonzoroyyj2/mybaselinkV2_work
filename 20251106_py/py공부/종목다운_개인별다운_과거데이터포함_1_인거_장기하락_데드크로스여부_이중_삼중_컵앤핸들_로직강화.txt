가장 중요한 개선 사항은 단순 가격 비교를 넘어 실제 투자에 활용되는 기술적 분석 기법을 도입했다는 점입니다.
1. 패턴 분석의 현실성 및 정확성 향상
넥라인(Neckline) 돌파 도입: 기존 코드는 단순히 두 저점의 가격이 비슷한지만 확인했습니다. 하지만 기술적 분석에서 이중 바닥은 두 번째 저점 형성 후, 그 사이에 있는 고점인 '넥라인'을 강하게 돌파해야 비로소 패턴이 완성되고 신뢰할 수 있는 매수 신호로 봅니다. 이 로직이 추가되어 더 현실적이고 정확한 분석이 가능해졌습니다.
잠재적 패턴 감지: 패턴이 완성되지는 않았지만 형성 과정에 있는 "잠재적 이중바닥"까지 감지할 수 있게 되어, 투자자가 미리 관심 종목으로 분류할 수 있습니다.
2. 기술적 견고함 향상 (Scipy 활용)
변동성 기반 고점/저점 감지: find_peaks 함수에서 prominence 인자를 단순히 고정값으로 사용하는 대신, 해당 종목의 주가 표준편차에 비례하도록 개선했습니다.
이는 삼성전자처럼 변동성이 적은 대형주와 테마주처럼 변동성이 큰 종목 모두에서 스케일에 관계없이 일관된 패턴을 감지할 수 있도록 해줍니다.
3. Java 연동 및 로깅 명확화
표준 출력(JSON)과 로그 분리: Java에서 파이썬의 표준 출력(stdout)을 파싱하여 결과를 가져온다는 요구사항을 반영하여, safe_print_json 함수를 통해 결과 JSON만 표준 출력으로 내보내고, 디버그/에러 로그는 파일(stock_analyzer_integrated.log)에 별도로 기록되도록 구조를 명확히 했습니다.



<form id="analysisForm">
    <h3>분석 유형 선택:</h3>
    <div>
        <input type="radio" name="analysisType" id="maRadio" value="ma" checked onclick="toggleMaPeriods()">
        <label for="maRadio">이동평균선(MA) 분석</label>
    </div>
    <div id="maPeriodsContainer" style="margin-left: 20px;">
        <input type="checkbox" name="maPeriods" value="200" checked> 200일선
        <input type="checkbox" name="maPeriods" value="500" checked> 500일선
        <input type="checkbox" name="maPeriods" value="60"> 60일선
    </div>

    <div>
        <input type="radio" name="analysisType" id="doubleBottomRadio" value="double_bottom" onclick="toggleMaPeriods()">
        <label for="doubleBottomRadio">이중바닥</label>
    </div>
    <div>
        <input type="radio" name="analysisType" id="tripleBottomRadio" value="triple_bottom" onclick="toggleMaPeriods()">
        <label for="tripleBottomRadio">삼중바닥</label>
    </div>
    <div>
        <input type="radio" name="analysisType" id="cupAndHandleRadio" value="cup_and_handle" onclick="toggleMaPeriods()">
        <label for="cupAndHandleRadio">컵앤핸들</label>
    </div>

    <button type="button" onclick="runAnalysis()">분석 실행</button>
</form>

<script>
function toggleMaPeriods() {
    const maPeriodsContainer = document.getElementById('maPeriodsContainer');
    const maRadio = document.getElementById('maRadio');
    if (maRadio.checked) {
        maPeriodsContainer.style.display = 'block';
    } else {
        maPeriodsContainer.style.display = 'none';
    }
}

function runAnalysis() {
    const analysisType = document.querySelector('input[name="analysisType"]:checked').value;
    let pythonArgs = ['analyze'];
    
    if (analysisType === 'ma') {
        const maCheckboxes = document.querySelectorAll('input[name="maPeriods"]:checked');
        const selectedPeriods = Array.from(maCheckboxes).map(cb => cb.value).join(',');
        if (selectedPeriods) {
            pythonArgs.push('--ma_periods', selectedPeriods);
        }
    } else {
        pythonArgs.push('--analyze_patterns');
        pythonArgs.push('--pattern_type', analysisType);
    }
    
    console.log("파이썬 스크립트에 전달될 인수:", pythonArgs);
    // 실제로는 이 pythonArgs를 자바 백엔드로 보냅니다.
}

// 페이지 로드 시 초기 상태 설정
window.onload = toggleMaPeriods;
</script>







import os
import sys
import json
import time
import logging
import argparse
import traceback
from pathlib import Path
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError

# ==============================
# 필수 라이브러리 확인 및 임포트
# ==============================
try:
    import FinanceDataReader as fdr
    import pandas as pd
    import mplfinance as mpf
    import matplotlib.pyplot as plt
    import io
    import base64
    import numpy as np
    from scipy.signal import find_peaks # 패턴 분석용
except ModuleNotFoundError as e:
    # Java에서 이 출력을 파싱할 수 있도록 JSON 형식 유지
    print(json.dumps({"error": f"필수 모듈 누락: {e.name} 설치 필요 (pip install {e.name})"}, ensure_ascii=False))
    sys.exit(1)

# ==============================
# 1?? 경로 설정 (사용자님의 기준 유지)
# ==============================
# 현재 파일 위치 기준 경로 설정: 상위 2단계 디렉터리를 BASE_DIR로 설정
BASE_DIR = Path(__file__).resolve().parents # 상위 2단계 디렉토리를 BASE_DIR로 설정
LOG_DIR = BASE_DIR / "log"
DATA_DIR = BASE_DIR / "data" / "stock_data"
LISTING_FILE = BASE_DIR / "data" / "stock_list" / "stock_listing.json"
LOG_FILE = LOG_DIR / "stock_analyzer_integrated.log"

# ==============================
# 2?? 환경 초기화 및 로깅 설정 (기존 방식 유지)
# ==============================
def setup_env():
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    LISTING_FILE.parent.mkdir(parents=True, exist_ok=True)

    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        handlers=[
            logging.FileHandler(LOG_FILE, encoding="utf-8"), # 파일 로그 (Java가 파싱할 stdout과 분리)
            logging.StreamHandler(sys.stdout) # 콘솔 출력 (Java가 stdout을 파싱하므로 주의)
        ]
    )

def safe_print_json(data):
    """표준 출력(stdout)으로 JSON 데이터를 안전하게 출력합니다. Java에서 이 출력을 파싱합니다."""
    # 표준 출력으로만 데이터를 보내고, 로그 핸들러가 stdout에 이중 출력하지 않도록 주의
    sys.__stdout__.write(json.dumps(data, ensure_ascii=False, indent=2) + "\n")
    sys.__stdout__.flush()

# ==============================
# 3?? 한글 폰트 설정 (차트용)
# ==============================
MPLFINANCE_FONT = 'sans-serif'
def set_korean_font():
    if sys.platform.startswith('win'): font_family = 'Malgun Gothic'
    elif sys.platform.startswith('darwin'): font_family = 'AppleGothic'
    else: font_family = 'NanumGothic'
    plt.rc('font', family=font_family)
    plt.rcParams['axes.unicode_minus'] = False
    global MPLFINANCE_FONT
    MPLFINANCE_FONT = font_family
set_korean_font()

# ==============================
# 4?? 종목 목록 관련 함수
# ==============================
def load_listing():
    if not LISTING_FILE.exists(): raise FileNotFoundError(f"종목 리스트 파일 없음: {LISTING_FILE}")
    with open(LISTING_FILE, "r", encoding="utf-8") as f: return json.load(f)

def get_stock_name(symbol):
    try:
        items = load_listing()
        for item in items:
            code = item.get("Code") or item.get("code")
            if code == symbol: return item.get("Name") or item.get("name")
        return symbol
    except Exception: return symbol


# ==============================
# 5?? 분석 로직 (장기 하락 추세, 골든/데드크로스, 패턴 분석) - 개선된 로직 적용
# ==============================

def find_peaks_and_troughs(df, prominence=0.01, width=3):
    """주어진 데이터프레임에서 고점(peaks)과 저점(troughs)을 감지합니다."""
    # prominence (현저성): 상대적 높이 차이 (퍼센트 비율로 조정하여 스케일 무관하게 적용)
    # width (너비): 최소한 이 정도 봉 개수 이상 지속되어야 패턴으로 인정
    peaks, _ = find_peaks(df['Close'], prominence=df['Close'].std() * prominence, width=width)
    troughs, _ = find_peaks(-df['Close'], prominence=df['Close'].std() * prominence, width=width)
    return peaks, troughs

def find_double_bottom(df, troughs, tolerance=0.02, neckline_breakout=True):
    """
    이중바닥 패턴을 감지하고, 넥라인 돌파 여부까지 확인합니다.
    반환값: (패턴 완성 여부 - Bool, 넥라인 가격 - Float, 잠재적 패턴 여부 - Bool)
    """
    if len(troughs) < 2:
        return False, None, None

    idx1, idx2 = troughs[-2], troughs[-1]
    price1, price2 = df['Close'].iloc[idx1], df['Close'].iloc[idx2]
    price_diff_ratio = abs(price1 - price2) / price1
    is_price_matching = price_diff_ratio < tolerance
    
    if not is_price_matching:
        return False, None, None

    interim_high = df['Close'].iloc[idx1:idx2].max()
    is_breakout = df['Close'].iloc[-1] > interim_high
    
    if neckline_breakout and not is_breakout:
        # 패턴은 형성되었지만 아직 돌파는 안 됨 (잠재적 패턴)
        return False, interim_high, True 
    
    # 넥라인 돌파를 확인하지 않거나, 돌파가 완료된 경우
    return True, interim_high, False


def check_ma_conditions(df, periods, analyze_patterns=False):
    results = {}
    
    if len(df) < 200: return results
    df['ma50'] = df['Close'].rolling(window=50).mean()
    df['ma200'] = df['Close'].rolling(window=200).mean()
    current_close = df['Close'].iloc[-1]
    
    for p in periods:
        if len(df) >= p:
            if p not in (50, 200): df[f'ma{p}'] = df['Close'].rolling(window=p).mean()
            results[f"below_ma{p}"] = current_close < df[f'ma{p}'].iloc[-1]
    
    results["goldencross_50_200_detected"] = (df['ma50'].iloc[-2] < df['ma200'].iloc[-2] and df['ma50'].iloc[-1] > df['ma200'].iloc[-1])
    results["deadcross_50_200_detected"] = (df['ma50'].iloc[-2] > df['ma200'].iloc[-2] and df['ma50'].iloc[-1] < df['ma200'].iloc[-1])

    if analyze_patterns:
        # 이중바닥 감지 (넥라인 돌파 확인 포함)
        peaks, troughs = find_peaks_and_troughs(df)
        is_double_bottom, neckline_price, is_potential = find_double_bottom(df, troughs, neckline_breakout=True)
        
        results['is_double_bottom'] = is_double_bottom
        if is_double_bottom:
            results['double_bottom_neckline'] = round(neckline_price, 2)
            results['pattern_description'] = f"이중바닥 패턴 형성 후 넥라인({neckline_price:.2f}원) 돌파 완료."
        elif is_potential:
             results['potential_double_bottom'] = True
             results['pattern_description'] = f"이중바닥 잠재적 형성. 넥라인({neckline_price:.2f}원) 돌파 필요."
        
    return results

def analyze_symbol(item, periods, analyze_patterns):
    code = item.get("Code") or item.get("code")
    name = item.get("Name") or item.get("name")
    path = DATA_DIR / f"{code}.parquet"
    if not path.exists(): return None
    try:
        df = pd.read_parquet(path)
        analysis_results = check_ma_conditions(df, periods, analyze_patterns) 
        # 하나 이상의 조건이 True이면 결과 반환
        if analysis_results and any(v for k, v in analysis_results.items() if isinstance(v, bool)):
            return {"ticker": code, "name": name, "as_of_date": df.index.max().strftime("%Y-%m-%d"), "conditions": analysis_results}
        return None
    except Exception as e:
        # 스레드 내부에서 발생하는 에러는 파일 로그에 기록
        logging.error(f"[ERROR] {code} {name} 분석 실패: {e}")
        return None

def run_analysis(workers, ma_periods_str, analyze_patterns):
    logging.info(f"[LOG] 분석 시작 (기간: {ma_periods_str}, 패턴 분석: {analyze_patterns})...")
    periods = [int(p.strip()) for p in ma_periods_str.split(',') if p.strip().isdigit()]
    if not periods:
        logging.error("유효한 MA 기간이 지정되지 않았습니다. (예: 200,500)")
        safe_print_json({"error": "유효한 MA 기간이 지정되지 않았습니다."}); sys.exit(1)
    items = load_listing()
    results = []
    start_time = time.time() # 시작 시간 기록
    total_count = len(items)
    completed_count = 0

    with ThreadPoolExecutor(max_workers=workers) as ex:
        futs = [ex.submit(analyze_symbol, i, periods, analyze_patterns) for i in items] 
        for i, f in enumerate(as_completed(futs)):
            r = f.result()
            if r: results.append(r)
            completed_count += 1
            # 진행률 출력 (Java에서 파싱 가능)
            progress = (completed_count / total_count) * 100
            logging.info(f"[PROGRESS] {progress:.1f} 현재 진행률")
            
    elapsed = time.time() - start_time
    logging.info(f"[LOG] 총 소요: {elapsed:.2f}초")
    logging.info("[PROGRESS] 100.0 전체 완료") # 100% 완료 신호
    logging.info(f"[LOG] 분석 완료, {len(results)}개 종목 발견")
    safe_print_json({"results": results, "mode": "analyze"})


# =====================================================
# 6?? 차트 생성 로직
# =====================================================
def generate_chart(symbol, ma_periods_str):
    try:
        periods = [int(p.strip()) for p in ma_periods_str.split(',') if p.strip().isdigit()]
        path = DATA_DIR / f"{symbol}.parquet"
        if not path.exists(): 
            safe_print_json({"error": f"데이터 파일 없음: {symbol}"})
            logging.error(f"데이터 파일 없음: {symbol}")
            sys.exit(1)
            
        df = pd.read_parquet(path)
        stock_name = get_stock_name(symbol)
        if df.empty: 
            safe_print_json({"error": f"{stock_name} ({symbol}) 데이터 없음"})
            logging.error(f"{stock_name} ({symbol}) 데이터 없음")
            return
            
        # 최근 1년 데이터만 사용
        df = df.loc[df.index >= (datetime.now() - timedelta(days=365)).strftime("%Y-%m-%d")]
        
        mc = mpf.make_marketcolors(up='red', down='blue', edge='inherit', wick='inherit', volume='inherit')
        s = mpf.make_mpf_style(base_mpf_style='yahoo', marketcolors=mc, rc={'font.family': MPLFINANCE_FONT})
        mav_periods = tuple(periods)
        fig, axes = mpf.plot(
            df, type="candle", mav=mav_periods, volume=True, style=s,
            title=f"[{stock_name} ({symbol})] 주가 및 거래량 차트 (MA: {ma_periods_str})",
            figsize=(12, 8), returnfig=True
        )
        
        if isinstance(axes, (list, np.ndarray)) and len(axes) > 0:
            ax = axes if isinstance(axes, np.ndarray) else axes
            ma_lines = ax.lines[-len(periods):] 
            for i, p in enumerate(periods):
                if i < len(ma_lines):
                    ma_lines[i].set_label(f'MA {p}일선')
            ax.legend(loc='best', fontsize='small')

        import matplotlib.dates as mdates
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
        plt.xticks(rotation=45, ha='right')
        
        buf = io.BytesIO()
        plt.savefig(buf, format="png", bbox_inches="tight")
        buf.seek(0)
        b64 = base64.b64encode(buf.read()).decode("utf-8")
        buf.close()
        plt.close(fig) 
        safe_print_json({"image_data": b64, "mode": "chart", "symbol": symbol})
        sys.exit(0)
    except Exception as e:
        logging.error(f"[ERROR] 차트 생성 실패: {e}") # 에러는 로그 파일에 기록
        safe_print_json({"error": f"차트 생성 실패: {e}"}) # 표준 출력으로는 에러 JSON만 출력
        sys.exit(1)


# ==============================
# 7?? 메인 함수: 모드 선택 및 인수 처리
# ==============================
def main():
    parser = argparse.ArgumentParser(description="주식 데이터 분석 및 차트 생성 스크립트")
    parser.add_argument("--mode", type=str, required=True, choices=['analyze', 'chart'], help="실행 모드 선택: 'analyze' 또는 'chart'")
    parser.add_argument("--workers", type=int, default=os.cpu_count() * 2, help="분석 모드에서 사용할 최대 스레드 수 (기본값: CPU 코어 수 * 2)")
    parser.add_argument("--ma_periods", type=str, default="50,200", help="이동 평균선 기간 지정 (쉼표로 구분, 예: '50,200')")
    parser.add_argument("--symbol", type=str, help="차트 모드에서 사용할 종목 코드 (예: '005930')")
    parser.add_argument("--analyze_patterns", action="store_true", help="분석 모드에서 이중바닥 같은 패턴 감지 활성화")

    args = parser.parse_args()

    setup_env()
    start_time = time.time() # 메인 함수 시작 시간 기록
    logging.info(f"스크립트 시작, 모드: {args.mode}")

    try:
        if args.mode == 'analyze':
            run_analysis(args.workers, args.ma_periods, args.analyze_patterns)
        elif args.mode == 'chart':
            if not args.symbol:
                logging.error("차트 모드에는 --symbol 인수가 필수입니다.")
                safe_print_json({"error": "--symbol 인수가 누락되었습니다."})
                sys.exit(1)
            generate_chart(args.symbol, args.ma_periods)
        else:
            logging.error("잘못된 모드입니다. 'analyze' 또는 'chart'를 선택하세요.")
            sys.exit(1)
    except Exception as e:
        # 예상치 못한 심각한 오류 발생 시 로그 기록 및 JSON 출력
        logging.error(f"[FATAL ERROR] 예상치 못한 오류 발생: {e}\n{traceback.format_exc()}")
        safe_print_json({"error": f"예상치 못한 오류 발생: {e}"})
        sys.exit(1)
    finally:
        elapsed = time.time() - start_time
        logging.info(f"[LOG] 메인 함수 총 소요: {elapsed:.2f}초")


if __name__ == "__main__":
    main()

