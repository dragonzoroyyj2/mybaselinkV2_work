네, 당연히 가능합니다!

웹 화면에 악재 종목 제외 여부를 선택하는 체크박스를 추가하고, 해당 선택 여부를 파이썬 스크립트에 인수로 전달하도록 JavaScript 함수를 수정할 수 있습니다.

이를 위해 파이썬 스크립트와 JavaScript 함수를 모두 수정해야 합니다.

??? 1단계: HTML 및 JavaScript 수정
폼에 악재 제외 체크박스를 추가하고, runAnalysis() 함수에서 그 값을 읽어 새로운 파라미터(--exclude_negatives)를 추가합니다.

?? 수정된 HTML/JavaScript 코드
HTML

<form id="analysisForm">
    <h3>분석 유형 선택:</h3>
    <div>
        <input type="radio" name="analysisType" id="maRadio" value="ma" checked onclick="toggleMaPeriods()">
        <label for="maRadio">이동평균선(MA) 분석</label>
    </div>
    <div id="maPeriodsContainer" style="margin-left: 20px;">
        <input type="checkbox" name="maPeriods" value="200" checked> 200일선
        <input type="checkbox" name="maPeriods" value="500" checked> 500일선
        <input type="checkbox" name="maPeriods" value="60"> 60일선
    </div>

    <div style="margin-top: 15px;">
        <input type="checkbox" id="excludeNegatives" name="excludeNegatives">
        <label for="excludeNegatives"><strong>악재 종목 제외 (뉴스/재무 기반 필터링)</strong></label>
    </div>
    <div>
        <input type="radio" name="analysisType" id="doubleBottomRadio" value="double_bottom" onclick="toggleMaPeriods()">
        <label for="doubleBottomRadio">이중바닥</label>
    </div>
    <div>
        <input type="radio" name="analysisType" id="tripleBottomRadio" value="triple_bottom" onclick="toggleMaPeriods()">
        <label for="tripleBottomRadio">삼중바닥</label>
    </div>
    <div>
        <input type="radio" name="analysisType" id="cupAndHandleRadio" value="cup_and_handle" onclick="toggleMaPeriods()">
        <label for="cupAndHandleRadio">컵앤핸들</label>
    </div>

    <button type="button" onclick="runAnalysis()">분석 실행</button>
</form>

<script>
function toggleMaPeriods() {
    const maPeriodsContainer = document.getElementById('maPeriodsContainer');
    const maRadio = document.getElementById('maRadio');
    if (maRadio.checked) {
        maPeriodsContainer.style.display = 'block';
    } else {
        maPeriodsContainer.style.display = 'none';
    }
}

function runAnalysis() {
    const analysisType = document.querySelector('input[name="analysisType"]:checked').value;
    const excludeNegatives = document.getElementById('excludeNegatives').checked; // 체크박스 상태 확인
    
    let pythonArgs = ['analyze'];
    
    if (analysisType === 'ma') {
        const maCheckboxes = document.querySelectorAll('input[name="maPeriods"]:checked');
        const selectedPeriods = Array.from(maCheckboxes).map(cb => cb.value).join(',');
        if (selectedPeriods) {
            pythonArgs.push('--ma_periods', selectedPeriods);
        }
    } else {
        pythonArgs.push('--analyze_patterns');
        pythonArgs.push('--pattern_type', analysisType); 
        // 참고: 현재 파이썬 스크립트는 --pattern_type을 사용하지 않고 --analyze_patterns만 사용하므로 이 부분은 2단계에서 조정해야 합니다.
    }
    
    // ?? 악재 제외 파라미터 추가
    if (excludeNegatives) {
        pythonArgs.push('--exclude_negatives');
    }

    console.log("파이썬 스크립트에 전달될 인수:", pythonArgs);
    // 실제로는 이 pythonArgs를 자바 백엔드로 보냅니다.
}

// 페이지 로드 시 초기 상태 설정
window.onload = toggleMaPeriods;
</script>



----------------------------------------------------------------

네, 악재 종목 제외 기능을 추가하고 웹 화면의 파라미터(`--exclude_negatives`)를 처리하도록 수정한 **전체 통합 코드**입니다.

이 코드에는 다음 세 가지 주요 변경 사항이 반영되었습니다.

1.  **`main` 및 `run_analysis` 함수 수정:** 새로운 인수 `--exclude_negatives`를 처리하도록 `argparse`와 함수 시그니처가 변경되었습니다.
2.  **`check_for_negatives` 함수 추가:** 뉴스 헤드라인 키워드와 ROE(적자), 부채비율(200% 초과) 기반의 악재 필터링 로직이 추가되었습니다.
3.  **`analyze_symbol` 함수 수정:** `--exclude_negatives` 플래그가 True일 때 필터링을 수행하고 악재 종목은 제외하도록 로직이 삽입되었습니다.

------------------------------------------------------

```python
import os
import sys
import json
import time
import logging
import argparse
import traceback
from pathlib import Path
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError

# ==============================
# 필수 라이브러리 확인 및 임포트
# ==============================
try:
    import FinanceDataReader as fdr
    import pandas as pd
    import mplfinance as mpf
    import matplotlib.pyplot as plt
    import io
    import base64
    import numpy as np
    from scipy.signal import find_peaks # 패턴 분석용
    import yfinance as yf # 재무정보 및 뉴스용
except ModuleNotFoundError as e:
    # 'pip install FinanceDataReader pandas mplfinance matplotlib numpy scipy yfinance'
    print(json.dumps({"error": f"필수 모듈 누락: {e.name} 설치 필요 (pip install {e.name})"}, ensure_ascii=False))
    sys.exit(1)

# ==============================
# 1. 경로 설정
# ==============================
# 주의: 실제 환경에 따라 Path(__file__).resolve().parents 경로 조정 필요
BASE_DIR = Path(__file__).resolve().parents[1] if Path(__file__).name != '<stdin>' else Path.cwd()
LOG_DIR = BASE_DIR / "log"
DATA_DIR = BASE_DIR / "data" / "stock_data"
LISTING_FILE = BASE_DIR / "data" / "stock_list" / "stock_listing.json"
LOG_FILE = LOG_DIR / "stock_analyzer_integrated.log"

# ==============================
# 2. 환경 초기화 및 로깅 설정
# ==============================
def setup_env():
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    LISTING_FILE.parent.mkdir(parents=True, exist_ok=True)
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        handlers=[
            logging.FileHandler(LOG_FILE, encoding="utf-8"),
            logging.StreamHandler(sys.stdout)
        ]
    )

def safe_print_json(data):
    # 표준 출력으로 JSON 결과를 안전하게 출력
    sys.__stdout__.write(json.dumps(data, ensure_ascii=False, indent=2) + "\n")
    sys.__stdout__.flush()

# ==============================
# 3. 한글 폰트 설정 (차트용)
# ==============================
MPLFINANCE_FONT = 'sans-serif'
def set_korean_font():
    if sys.platform.startswith('win'): font_family = 'Malgun Gothic'
    elif sys.platform.startswith('darwin'): font_family = 'AppleGothic'
    else: font_family = 'NanumGothic' # Linux 환경을 위한 기본 설정
    plt.rc('font', family=font_family)
    plt.rcParams['axes.unicode_minus'] = False
    global MPLFINANCE_FONT
    MPLFINANCE_FONT = font_family
set_korean_font()

# ==============================
# 4. 종목 목록 관련 함수
# ==============================
def load_listing():
    if not LISTING_FILE.exists(): 
        logging.error(f"종목 리스트 파일 없음: {LISTING_FILE}")
        # 임시 데이터 반환 (실제 사용 시 FileNotFoundError로 대체 필요)
        return [{"Code": "005930", "Name": "삼성전자"}] 
        # raise FileNotFoundError(f"종목 리스트 파일 없음: {LISTING_FILE}")
        
    with open(LISTING_FILE, "r", encoding="utf-8") as f: return json.load(f)

def get_stock_name(symbol):
    try:
        items = load_listing()
        for item in items:
            code = item.get("Code") or item.get("code")
            if code == symbol: return item.get("Name") or item.get("name")
        return symbol
    except Exception: return symbol

# ==============================
# 5. 분석 로직 (기술적/기본적 분석 통합)
# ==============================

def find_peaks_and_troughs(df, prominence=0.01, width=3):
    peaks, _ = find_peaks(df['Close'], prominence=df['Close'].std() * prominence, width=width)
    troughs, _ = find_peaks(-df['Close'], prominence=df['Close'].std() * prominence, width=width)
    return peaks, troughs

def find_double_bottom(df, troughs, tolerance=0.02, neckline_breakout=True):
    if len(troughs) < 2: return False, None, None
    idx1, idx2 = troughs[-2], troughs[-1]
    price1, price2 = df['Close'].iloc[idx1], df['Close'].iloc[idx2]
    price_diff_ratio = abs(price1 - price2) / price1
    is_price_matching = price_diff_ratio < tolerance
    if not is_price_matching: return False, None, None
    interim_high = df['Close'].iloc[idx1:idx2].max()
    is_breakout = df['Close'].iloc[-1] > interim_high
    if neckline_breakout and not is_breakout: return False, interim_high, True
    return True, interim_high, False

def find_triple_bottom(df, troughs, tolerance=0.02, neckline_breakout=True):
    if len(troughs) < 3: return False, None, None
    idx1, idx2, idx3 = troughs[-3], troughs[-2], troughs[-1]
    price1, price2, price3 = df['Close'].iloc[idx1], df['Close'].iloc[idx2], df['Close'].iloc[idx3]
    is_price_matching = (abs(price1 - price2) / price1 < tolerance and
                         abs(price2 - price3) / price2 < tolerance)
    if not is_price_matching: return False, None, None
    interim_high1 = df['Close'].iloc[idx1:idx2].max()
    interim_high2 = df['Close'].iloc[idx2:idx3].max()
    neckline_high = max(interim_high1, interim_high2)
    is_breakout = df['Close'].iloc[-1] > neckline_high
    if neckline_breakout and not is_breakout: return False, neckline_high, True
    return True, neckline_high, False

def find_cup_and_handle(df, peaks, troughs, min_cup_depth=0.1, max_handle_depth_ratio=0.5, handle_pos_ratio=0.5):
    if len(peaks) < 2 or len(troughs) < 1: return False, None, None, None
    for i in range(len(peaks) - 1, 0, -1):
        right_peak_idx = peaks[i]
        left_peak_idx = peaks[i-1]
        if right_peak_idx - left_peak_idx < 20: continue
        cup_high = df['High'].iloc[left_peak_idx]
        troughs_in_cup = [t for t in troughs if left_peak_idx < t < right_peak_idx]
        if not troughs_in_cup: continue
        cup_low = df['Low'].iloc[troughs_in_cup[np.argmin(df['Low'].iloc[troughs_in_cup])]]
        cup_depth = (cup_high - cup_low) / cup_high
        if cup_depth < min_cup_depth: continue
        handle_start_idx = right_peak_idx
        df_handle = df.iloc[handle_start_idx:]
        if len(df_handle) < 5: continue
        handle_high = df_handle['High'].max()
        handle_low = df_handle['Low'].min()
        handle_depth = (handle_high - handle_low) / cup_high
        if handle_depth > cup_depth * max_handle_depth_ratio or handle_low < cup_high * handle_pos_ratio: continue
        breakout_price = df['Close'].iloc[-1]
        if breakout_price > handle_high: return True, cup_high, handle_high, breakout_price
    return False, None, None, None

def get_fundamental_data(code):
    """yfinance를 이용해 재무비율과 뉴스를 가져옵니다."""
    try:
        # 한국 코스피 종목은 .KS를 붙여 yfinance에서 검색
        yf_ticker = f"{code}.KS" if not code.endswith('.KS') else code
        ticker = yf.Ticker(yf_ticker)
        info = ticker.info
        
        fundamentals = {
            'PER': info.get('trailingPE'),
            'PBR': info.get('priceToBook'),
            # ROE는 보통 decimal 값으로 들어오므로 100을 곱함
            'ROE': info.get('returnOnEquity') * 100 if info.get('returnOnEquity') is not None else None, 
            'DebtToEquity': info.get('debtToEquity'),
        }
        
        # 재무 상태 평가 (필터링 기준에 맞게 조정)
        if fundamentals['ROE'] is not None and fundamentals['ROE'] < 0:
            fundamentals['FinancialStatus'] = '적자 (ROE < 0%)'
        elif fundamentals['DebtToEquity'] is not None and fundamentals['DebtToEquity'] > 200:
            fundamentals['FinancialStatus'] = '위험 (부채비율 > 200%)'
        elif fundamentals['ROE'] is not None and fundamentals['ROE'] > 10:
            fundamentals['FinancialStatus'] = '우수 (ROE > 10%)'
        elif fundamentals['ROE'] is not None and fundamentals['ROE'] > 0:
            fundamentals['FinancialStatus'] = '양호'
        else:
            fundamentals['FinancialStatus'] = '보통/정보없음'

        # 뉴스 가져오기 및 날짜 필터링
        news_list = ticker.news
        filtered_headlines = []
        two_months_ago = datetime.now() - timedelta(days=60)

        for news in news_list:
            publish_date = datetime.fromtimestamp(news.get('providerPublishTime'))
            if publish_date >= two_months_ago:
                filtered_headlines.append({
                    "title": news.get('title'),
                    "link": news.get('link'),
                    "date": publish_date.strftime("%Y-%m-%d")
                })
            if len(filtered_headlines) >= 3: # 최대 3건만 가져옴
                break
        
        return fundamentals, filtered_headlines
    except Exception as e:
        logging.error(f"[ERROR] yfinance 데이터 가져오기 실패 ({code}): {e}")
        return {}, []

def check_ma_conditions(df, periods, analyze_patterns=False):
    results = {}
    if len(df) < 200: return results
    
    # 50일선, 200일선은 골든/데드크로스 분석을 위해 필수 계산
    df['ma50'] = df['Close'].rolling(window=50).mean()
    df['ma200'] = df['Close'].rolling(window=200).mean()
    
    current_close = df['Close'].iloc[-1]
    
    # 지정된 기간에 대한 분석
    for p in periods:
        if len(df) >= p:
            # 50, 200일선은 이미 계산되었으므로 스킵
            if p not in (50, 200): df[f'ma{p}'] = df['Close'].rolling(window=p).mean() 
            results[f"below_ma{p}"] = current_close < df[f'ma{p}'].iloc[-1]
    
    # 크로스 분석
    results["goldencross_50_200_detected"] = (df['ma50'].iloc[-2] < df['ma200'].iloc[-2] and df['ma50'].iloc[-1] > df['ma200'].iloc[-1])
    results["deadcross_50_200_detected"] = (df['ma50'].iloc[-2] > df['ma200'].iloc[-2] and df['ma50'].iloc[-1] < df['ma200'].iloc[-1])
    
    # 패턴 분석
    if analyze_patterns:
        peaks, troughs = find_peaks_and_troughs(df)

        is_double_bottom, neckline_price_db, is_potential_db = find_double_bottom(df, troughs, neckline_breakout=True)
        results['is_double_bottom'] = is_double_bottom
        if is_double_bottom: results['pattern_description_db'] = f"이중바닥 패턴 형성 후 넥라인({neckline_price_db:.2f}원) 돌파 완료."
        elif is_potential_db: results['pattern_description_db'] = f"이중바닥 잠재적 형성. 넥라인({neckline_price_db:.2f}원) 돌파 필요."
        
        is_triple_bottom, neckline_price_tb, is_potential_tb = find_triple_bottom(df, troughs, neckline_breakout=True)
        results['is_triple_bottom'] = is_triple_bottom
        if is_triple_bottom: results['pattern_description_tb'] = f"삼중바닥 패턴 형성 후 넥라인({neckline_price_tb:.2f}원) 돌파 완료."
        elif is_potential_tb: results['pattern_description_tb'] = f"삼중바닥 잠재적 형성. 넥라인({neckline_price_tb:.2f}원) 돌파 필요."

        is_cup_and_handle, cup_high, handle_high, breakout_price_ch = find_cup_and_handle(df, peaks, troughs)
        results['is_cup_and_handle'] = is_cup_and_handle
        if is_cup_and_handle: results['pattern_description_ch'] = f"컵앤핸들 패턴 형성 후 저항선({handle_high:.2f}원) 돌파 완료."
        # 잠재적인 컵앤핸들 패턴도 기록
        elif is_cup_and_handle is False and cup_high is not None: results['potential_cup_and_handle'] = True
                
    return results

def check_for_negatives(fundamentals, headlines):
    """뉴스 헤드라인 및 재무 건전성 기반으로 악재성 종목 여부를 검사"""
    
    # 1. 뉴스 헤드라인 기반 검사 (키워드: 횡령, 소송, 분쟁 등)
    negative_keywords = ["횡령", "배임", "소송", "분쟁", "감사 의견 거절", "파산", "거래 정지", "악재", "하락 전망", "투자주의"]
    for news in headlines:
        title = news.get('title', '')
        if any(keyword in title for keyword in negative_keywords):
            return True, f"뉴스 악재: '{title}'"
            
    # 2. 재무 건전성 기반 검사 (ROE 적자 또는 과도한 부채)
    roe = fundamentals.get('ROE')
    debt_to_equity = fundamentals.get('DebtToEquity')
    
    # ROE가 0 미만인 경우 (적자)
    if roe is not None and roe < 0:
        return True, f"재무 악재: ROE {roe:.1f}% (적자)"
        
    # 부채비율이 200% 초과 시 (과도한 부채)
    if debt_to_equity is not None and debt_to_equity > 200: 
        return True, f"재무 악재: 부채비율 {debt_to_equity:.1f}% 초과 (200% 기준)"
        
    return False, None


def analyze_symbol(item, periods, analyze_patterns, exclude_negatives): # ?? exclude_negatives 인자 추가
    code = item.get("Code") or item.get("code")
    name = item.get("Name") or item.get("name")
    path = DATA_DIR / f"{code}.parquet"
    if not path.exists(): return None
    
    try:
        df = pd.read_parquet(path)
        # 데이터가 너무 적으면 분석 불가
        if len(df) < 50: return None 
        
        analysis_results = check_ma_conditions(df, periods, analyze_patterns) 
        fundamentals, headlines = get_fundamental_data(code)
        
        # ?? 악재 제외 플래그가 True일 경우 필터링 로직 실행
        if exclude_negatives:
            is_negative, reason = check_for_negatives(fundamentals, headlines)
            if is_negative:
                logging.warning(f"[FILTERED] {name} ({code}): 악재로 제외됨. 이유: {reason}")
                return None
        # ----------------------------------------------------
        
        # 기술적 조건이나 펀더멘털, 뉴스가 있을 경우에만 결과 반환
        if analysis_results or fundamentals or headlines:
            combined_results = {
                "ticker": code,
                "name": name,
                "as_of_date": df.index.max().strftime("%Y-%m-%d"),
                "technical_conditions": analysis_results,
                "fundamentals": fundamentals,
                "recent_news_headlines": headlines
            }
            return combined_results
        return None
    except Exception as e:
        logging.error(f"[ERROR] {code} {name} 분석 실패: {e}\n{traceback.format_exc()}")
        return None

def run_analysis(workers, ma_periods_str, analyze_patterns, exclude_negatives): # ?? exclude_negatives 인자 추가
    logging.info(f"[LOG] 분석 시작 (기간: {ma_periods_str}, 패턴 분석: {analyze_patterns}, 악재 제외: {exclude_negatives})...")
    periods = [int(p.strip()) for p in ma_periods_str.split(',') if p.strip().isdigit()]
    if not periods and not analyze_patterns:
        logging.error("유효한 MA 기간 또는 패턴 분석이 지정되지 않았습니다.")
        safe_print_json({"error": "유효한 MA 기간 또는 패턴 분석이 지정되지 않았습니다."}); sys.exit(1)

    items = load_listing()
    results = []
    start_time = time.time()
    total_count = len(items)
    completed_count = 0

    with ThreadPoolExecutor(max_workers=workers) as ex:
        # ?? analyze_symbol에 exclude_negatives 인자를 전달
        futs = [ex.submit(analyze_symbol, i, periods, analyze_patterns, exclude_negatives) for i in items]
        for i, f in enumerate(as_completed(futs)):
            r = None
            try:
                r = f.result(timeout=30) # 개별 종목 분석 타임아웃 30초 설정
            except TimeoutError:
                logging.error(f"[ERROR] 분석 시간 초과: {items[i].get('Code')}")
            except Exception as e:
                 logging.error(f"[ERROR] 분석 중 예기치 않은 오류 발생: {e}")
            
            if r: results.append(r)
            completed_count += 1
            progress = (completed_count / total_count) * 100
            # 100개 종목마다 진행률 로깅 (너무 잦은 로깅 방지)
            if completed_count % 100 == 0 or completed_count == total_count: 
                 logging.info(f"[PROGRESS] {progress:.1f} 현재 진행률")
            
    elapsed = time.time() - start_time
    logging.info(f"[LOG] 총 소요: {elapsed:.2f}초")
    logging.info("[PROGRESS] 100.0 전체 완료")
    logging.info(f"[LOG] 분석 완료, {len(results)}개 종목 발견")
    safe_print_json({"results": results, "mode": "analyze"})

# =====================================================
# 6. 차트 생성 로직
# =====================================================
def generate_chart(symbol, ma_periods_str):
    try:
        periods = [int(p.strip()) for p in ma_periods_str.split(',') if p.strip().isdigit()]
        path = DATA_DIR / f"{symbol}.parquet"
        if not path.exists(): 
            safe_print_json({"error": f"데이터 파일 없음: {symbol}"})
            logging.error(f"데이터 파일 없음: {symbol}")
            sys.exit(1)
            
        df = pd.read_parquet(path)
        stock_name = get_stock_name(symbol)
        if df.empty: 
            safe_print_json({"error": f"{stock_name} ({symbol}) 데이터 없음"})
            logging.error(f"{stock_name} ({symbol}) 데이터 없음")
            return
            
        # 최근 1년간의 데이터만 사용
        df = df.loc[df.index >= (datetime.now() - timedelta(days=365)).strftime("%Y-%m-%d")]
        
        # 차트 스타일 설정
        mc = mpf.make_marketcolors(up='red', down='blue', edge='inherit', wick='inherit', volume='inherit')
        s = mpf.make_mpf_style(base_mpf_style='yahoo', marketcolors=mc, rc={'font.family': MPLFINANCE_FONT})
        mav_periods = tuple(periods)
        
        # mplfinance 차트 생성
        fig, axes = mpf.plot(
            df, type="candle", mav=mav_periods, volume=True, style=s,
            title=f"[{stock_name} ({symbol})] 주가 및 거래량 차트 (MA: {ma_periods_str})",
            figsize=(12, 8), returnfig=True
        )
        
        # 범례 추가
        if isinstance(axes, (list, np.ndarray)) and len(axes) > 0:
            ax = axes[0] if isinstance(axes, np.ndarray) and len(axes) > 0 else (axes if isinstance(axes, list) else None)
            if ax:
                ma_lines = ax.lines[-len(periods):] 
                for i, p in enumerate(periods):
                    if i < len(ma_lines): ma_lines[i].set_label(f'MA {p}일선')
                ax.legend(loc='best', fontsize='small')

        import matplotlib.dates as mdates
        if isinstance(axes, np.ndarray) and len(axes) > 0:
             # axes[0]는 캔들 차트, axes[2]는 볼륨 차트
             axes[0].xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
             axes[0].tick_params(axis='x', rotation=45)
        
        # 차트 이미지를 PNG로 변환 후 Base64 인코딩
        buf = io.BytesIO()
        plt.savefig(buf, format="png", bbox_inches="tight")
        buf.seek(0)
        b64 = base64.b64encode(buf.read()).decode("utf-8")
        buf.close()
        plt.close(fig) 
        
        safe_print_json({"image_data": b64, "mode": "chart", "symbol": symbol})
        sys.exit(0)
    except Exception as e:
        logging.error(f"[ERROR] 차트 생성 실패: {e}\n{traceback.format_exc()}")
        safe_print_json({"error": f"차트 생성 실패: {e}"})
        sys.exit(1)


# ==============================
# 7. 메인 함수: 모드 선택 및 인수 처리
# ==============================
def main():
    parser = argparse.ArgumentParser(description="주식 데이터 분석 및 차트 생성 스크립트")
    parser.add_argument("--mode", type=str, required=True, choices=['analyze', 'chart'], help="실행 모드 선택: 'analyze' 또는 'chart'")
    parser.add_argument("--workers", type=int, default=os.cpu_count() * 2, help="분석 모드에서 사용할 최대 스레드 수 (기본값: CPU 코어 수 * 2)")
    parser.add_argument("--ma_periods", type=str, default="50,200", help="이동 평균선 기간 지정 (쉼표로 구분, 예: '50,200')")
    parser.add_argument("--symbol", type=str, help="차트 모드에서 사용할 종목 코드 (예: '005930')")
    parser.add_argument("--analyze_patterns", action="store_true", help="분석 모드에서 패턴 감지 활성화")
    parser.add_argument("--pattern_type", type=str, choices=['double_bottom', 'triple_bottom', 'cup_and_handle'], help="분석 모드에서 감지할 패턴 종류")
    # ?? 악재 제외 인수 추가
    parser.add_argument("--exclude_negatives", action="store_true", help="뉴스 및 재무 상태를 기반으로 악재성 종목 제외")

    args = parser.parse_args()

    setup_env()
    start_time = time.time()
    logging.info(f"스크립트 시작, 모드: {args.mode}")

    try:
        if args.mode == 'analyze':
            # 패턴 타입이 지정되면 analyze_patterns 강제 활성화 (웹 인터페이스 연동 고려)
            if args.pattern_type:
                args.analyze_patterns = True
                
            # ?? run_analysis에 exclude_negatives 인수를 전달
            run_analysis(args.workers, args.ma_periods, args.analyze_patterns, args.exclude_negatives) 
        elif args.mode == 'chart':
            if not args.symbol:
                logging.error("차트 모드에는 --symbol 인수가 필수입니다.")
                safe_print_json({"error": "--symbol 인수가 누락되었습니다."})
                sys.exit(1)
            generate_chart(args.symbol, args.ma_periods)
        else:
            logging.error("잘못된 모드입니다. 'analyze' 또는 'chart'를 선택하세요.")
            sys.exit(1)
    except Exception as e:
        logging.error(f"[FATAL ERROR] 예상치 못한 오류 발생: {e}\n{traceback.format_exc()}")
        safe_print_json({"error": f"예상치 못한 오류 발생: {e}"})
        sys.exit(1)
    finally:
        elapsed = time.time() - start_time
        logging.info(f"[LOG] 메인 함수 총 소요: {elapsed:.2f}초")


if __name__ == "__main__":
    main()
```