네, 요청하신 내용을 모두 통합하여 단일 Python 스크립트로 제공합니다.

이 스크립트(stock_analyzer_integrated.py로 가정)는 다음 세 가지 주요 기능을 수행합니다.

분석 모드 (--mode analyze): 지정된 기술적 패턴(--pattern_type)과 이동평균선 조건을 만족하는 종목을 검색합니다. 필요 시 뉴스/재무/공시 기반의 악재 종목을 제외합니다 (--exclude_negatives).

차트 모드 (--mode chart): 특정 종목(--symbol)에 대한 캔들/거래량 차트를 생성하고 Base64로 인코딩하여 출력합니다.

악재 필터링: yfinance 기반 재무/뉴스 악재와 dart-fss 기반 공시 악재를 통합 검사합니다.

?? 필수 전제 조건
이 코드를 실행하기 위해서는 다음 라이브러리들이 설치되어 있어야 합니다.

Bash

pip install FinanceDataReader pandas mplfinance matplotlib numpy scipy yfinance dart-fss


--------------------------------------------------------------
import os
import sys
import json
import time
import logging
import argparse
import traceback
from pathlib import Path
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError

# ==============================
# 필수 라이브러리 확인 및 임포트
# ==============================
try:
    import FinanceDataReader as fdr
    import pandas as pd
    import mplfinance as mpf
    import matplotlib.pyplot as plt
    import io
    import base64
    import numpy as np
    from scipy.signal import find_peaks # 패턴 분석용
    import yfinance as yf # 재무정보 및 뉴스용
    
    # DART 공시 필터링을 위한 라이브러리 확인
    try:
        from dart_fss import Dart, get_corp_code_list
        DART_AVAILABLE = True
    except ImportError:
        DART_AVAILABLE = False
        print("경고: dart-fss 모듈이 설치되지 않아 공시 필터링이 비활성화됩니다. (pip install dart-fss)")

except ModuleNotFoundError as e:
    print(json.dumps({"error": f"필수 모듈 누락: {e.name} 설치 필요"}, ensure_ascii=False))
    sys.exit(1)

# ==============================
# 1. 경로 및 상수 설정
# ==============================
# 주의: 실제 환경에 따라 Path(__file__).resolve().parents 경로 조정 필요
BASE_DIR = Path(__file__).resolve().parents[1] if Path(__file__).name != '<stdin>' else Path.cwd()
LOG_DIR = BASE_DIR / "log"
DATA_DIR = BASE_DIR / "data" / "stock_data"
LISTING_FILE = BASE_DIR / "data" / "stock_list" / "stock_listing.json"
LOG_FILE = LOG_DIR / "stock_analyzer_integrated.log"

# ?? DART API KEY 설정 (발급받은 키로 교체 필요)
DART_API_KEY = "YOUR_DART_API_KEY_HERE" 

# ==============================
# 2. 환경 초기화 및 로깅 설정
# ==============================
def setup_env():
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    LISTING_FILE.parent.mkdir(parents=True, exist_ok=True)
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        handlers=[
            logging.FileHandler(LOG_FILE, encoding="utf-8"),
            logging.StreamHandler(sys.stdout)
        ]
    )

def safe_print_json(data):
    sys.__stdout__.write(json.dumps(data, ensure_ascii=False, indent=2) + "\n")
    sys.__stdout__.flush()

# ==============================
# 3. 한글 폰트 설정 및 종목 정보 로드
# ==============================
MPLFINANCE_FONT = 'sans-serif'
def set_korean_font():
    if sys.platform.startswith('win'): font_family = 'Malgun Gothic'
    elif sys.platform.startswith('darwin'): font_family = 'AppleGothic'
    else: font_family = 'NanumGothic'
    plt.rc('font', family=font_family)
    plt.rcParams['axes.unicode_minus'] = False
    global MPLFINANCE_FONT
    MPLFINANCE_FONT = font_family
set_korean_font()

def load_listing():
    if not LISTING_FILE.exists(): 
        logging.error(f"종목 리스트 파일 없음: {LISTING_FILE}")
        # 임시 데이터 반환 (실제 사용 시 목록 파일 준비 필수)
        return [{"Code": "005930", "Name": "삼성전자"}] 
        
    with open(LISTING_FILE, "r", encoding="utf-8") as f: return json.load(f)

def get_stock_name(symbol):
    try:
        items = load_listing()
        for item in items:
            code = item.get("Code") or item.get("code")
            if code == symbol: return item.get("Name") or item.get("name")
        return symbol
    except Exception: return symbol

# ==============================
# 4. 기술적 분석 패턴 로직
# ==============================

def find_peaks_and_troughs(df, prominence=0.01, width=3):
    """주요 봉우리와 골짜기 인덱스 찾기"""
    # 평균 변동성 기준으로 prominence 설정
    std_dev = df['Close'].std()
    peaks, _ = find_peaks(df['Close'], prominence=std_dev * prominence, width=width)
    troughs, _ = find_peaks(-df['Close'], prominence=std_dev * prominence, width=width)
    return peaks, troughs

def find_double_bottom(df, troughs, tolerance=0.02, neckline_breakout=True):
    """이중 바닥 패턴 감지"""
    if len(troughs) < 2: return False, None, None
    idx1, idx2 = troughs[-2], troughs[-1]
    price1, price2 = df['Close'].iloc[idx1], df['Close'].iloc[idx2]
    
    # 두 저점 가격 유사성 검사
    is_price_matching = abs(price1 - price2) / price1 < tolerance
    if not is_price_matching: return False, None, None
    
    # 중간 고점 (넥라인) 찾기
    interim_high = df['Close'].iloc[idx1:idx2].max()
    
    # 넥라인 돌파 여부 확인
    is_breakout = df['Close'].iloc[-1] > interim_high
    
    if neckline_breakout and not is_breakout:
        # 잠재적 패턴만 형성, 돌파 대기
        return False, interim_high, True # is_potential = True
        
    return is_breakout, interim_high, False # is_breakout = True/False, is_potential = False

def find_triple_bottom(df, troughs, tolerance=0.02, neckline_breakout=True):
    """삼중 바닥 패턴 감지"""
    if len(troughs) < 3: return False, None, None
    idx1, idx2, idx3 = troughs[-3], troughs[-2], troughs[-1]
    price1, price2, price3 = df['Close'].iloc[idx1], df['Close'].iloc[idx2], df['Close'].iloc[idx3]
    
    # 세 저점 가격 유사성 검사
    is_price_matching = (abs(price1 - price2) / price1 < tolerance and
                         abs(price2 - price3) / price2 < tolerance)
    if not is_price_matching: return False, None, None
    
    # 넥라인 찾기 (중간 고점 중 최고점)
    interim_high1 = df['Close'].iloc[idx1:idx2].max()
    interim_high2 = df['Close'].iloc[idx2:idx3].max()
    neckline_high = max(interim_high1, interim_high2)
    
    # 넥라인 돌파 여부 확인
    is_breakout = df['Close'].iloc[-1] > neckline_high
    
    if neckline_breakout and not is_breakout:
        return False, neckline_high, True # is_potential = True
        
    return is_breakout, neckline_high, False # is_breakout = True/False, is_potential = False

def find_cup_and_handle(df, peaks, troughs, min_cup_depth=0.1):
    """컵 앤 핸들 패턴 감지 (단순화된 로직)"""
    # 컵의 깊이가 최소 10% 이상인 경우만 탐색
    if len(peaks) < 2 or len(troughs) < 1: return False, None, None
    
    for i in range(len(peaks) - 1, 0, -1):
        right_peak_idx = peaks[i]
        left_peak_idx = peaks[i-1]
        
        # 컵의 폭이 최소 20 거래일 이상
        if right_peak_idx - left_peak_idx < 20: continue 
        
        cup_high = df['High'].iloc[left_peak_idx]
        troughs_in_cup = [t for t in troughs if left_peak_idx < t < right_peak_idx]
        if not troughs_in_cup: continue
        
        cup_low = df['Low'].iloc[troughs_in_cup[np.argmin(df['Low'].iloc[troughs_in_cup])]]
        cup_depth = (cup_high - cup_low) / cup_high
        
        if cup_depth < min_cup_depth: continue # 최소 깊이 만족 못함
        
        # 핸들 부분 정의: 우측 고점 이후 현재까지
        df_handle = df.iloc[right_peak_idx:]
        if len(df_handle) < 5: continue
        
        handle_high = df_handle['High'].max()
        
        # 핸들이 컵의 오른쪽 끝 고점(right_peak_idx)보다 높지 않고, 깊은 조정이 아닐 경우
        # (Handle High가 Cup High보다 낮아야 함, 실질적인 조정)
        if handle_high > cup_high * 1.05 : continue 
        
        # 돌파 확인: 현재 종가가 핸들 고점(저항선)을 돌파했는지
        breakout_price = df['Close'].iloc[-1]
        if breakout_price > handle_high: 
            return True, cup_high, handle_high, breakout_price

    return False, None, None, None

# ==============================
# 5. 기본적 분석 및 악재 필터링 로직
# ==============================

def get_fundamental_data(code):
    """yfinance를 이용해 재무비율과 뉴스를 가져옵니다."""
    # (이전 코드와 동일한 yfinance 호출 로직)
    try:
        yf_ticker = f"{code}.KS" if not code.endswith('.KS') else code
        ticker = yf.Ticker(yf_ticker)
        info = ticker.info
        
        fundamentals = {
            'PER': info.get('trailingPE'),
            'PBR': info.get('priceToBook'),
            'ROE': info.get('returnOnEquity') * 100 if info.get('returnOnEquity') is not None else None, 
            'DebtToEquity': info.get('debtToEquity'),
        }
        
        # 뉴스 가져오기 및 날짜 필터링 (최대 3건)
        news_list = ticker.news
        filtered_headlines = []
        two_months_ago = datetime.now() - timedelta(days=60)

        for news in news_list:
            publish_date = datetime.fromtimestamp(news.get('providerPublishTime'))
            if publish_date >= two_months_ago:
                filtered_headlines.append({"title": news.get('title'), "link": news.get('link')})
            if len(filtered_headlines) >= 3: break
        
        return fundamentals, filtered_headlines
    except Exception as e:
        return {}, []

def check_for_negative_dart_disclosures(corp_code):
    """DART API를 사용하여 악재성 공시를 확인합니다."""
    if not DART_AVAILABLE or not DART_API_KEY or DART_API_KEY == "YOUR_DART_API_KEY_HERE":
        return False, None
        
    try:
        dart = Dart(DART_API_KEY)
        end_date = datetime.now()
        start_date = end_date - timedelta(days=60)

        reports = dart.search(
            corp_code=corp_code, 
            start_dt=start_date.strftime('%Y%m%d'),
            end_dt=end_date.strftime('%Y%m%d'),
        )

        negative_keywords = ["횡령", "배임", "소송 제기", "손해배상", "거래정지", "상장폐지", "감사의견 거절", "유상증자 결정"]

        for report in reports:
            report_nm = report.report_nm
            if any(keyword in report_nm for keyword in negative_keywords):
                # 제3자배정 유상증자는 긍정적일 수 있으므로 제외하는 필터링 예시
                if "유상증자 결정" in report_nm and "제3자배정" in report_nm:
                    continue 
                return True, f"공시 악재: '{report_nm}'"

        return False, None

    except Exception as e:
        # logging.error(f"[ERROR] DART 공시 조회 실패 ({corp_code}): {e}")
        return False, None

def check_for_negatives(fundamentals, headlines, code, corp_code):
    """뉴스/재무/공시 기반으로 악재성 종목 여부를 검사"""
    
    # 1. 뉴스 헤드라인 기반 검사 (yfinance)
    negative_keywords_news = ["횡령", "배임", "소송", "분쟁", "거래 정지", "악재", "하락 전망", "투자주의"]
    for news in headlines:
        title = news.get('title', '')
        if any(keyword in title for keyword in negative_keywords_news):
            return True, f"뉴스 악재: '{title}'"
            
    # 2. 재무 건전성 기반 검사 (yfinance)
    roe = fundamentals.get('ROE')
    debt_to_equity = fundamentals.get('DebtToEquity')
    if roe is not None and roe < 0:
        return True, f"재무 악재: ROE {roe:.1f}% (적자)"
    if debt_to_equity is not None and debt_to_equity > 200: 
        return True, f"재무 악재: 부채비율 {debt_to_equity:.1f}% 초과 (200% 기준)"

    # 3. DART 공시 기반 검사 (dart-fss)
    if corp_code:
        is_negative_dart, reason_dart = check_for_negative_dart_disclosures(corp_code)
        if is_negative_dart:
            return True, reason_dart
        
    return False, None

# ==============================
# 6. 분석 실행 및 필터링
# ==============================

def check_ma_conditions(df, periods, analyze_patterns=False):
    """이동 평균선 및 패턴 분석을 수행하고 결과를 반환합니다."""
    results = {}
    if len(df) < 200: return results
    
    # 이동평균선 계산
    for p in periods:
        if len(df) >= p:
            df[f'ma{p}'] = df['Close'].rolling(window=p).mean() 
            results[f"below_ma{p}"] = df['Close'].iloc[-1] < df[f'ma{p}'].iloc[-1]
            results[f"above_ma{p}"] = df['Close'].iloc[-1] > df[f'ma{p}'].iloc[-1]
    
    # 크로스 분석 (50일선, 200일선)
    if 'ma50' in df.columns and 'ma200' in df.columns and len(df) >= 200:
        results["goldencross_50_200_detected"] = (df['ma50'].iloc[-2] < df['ma200'].iloc[-2] and df['ma50'].iloc[-1] > df['ma200'].iloc[-1])
        results["deadcross_50_200_detected"] = (df['ma50'].iloc[-2] > df['ma200'].iloc[-2] and df['ma50'].iloc[-1] < df['ma200'].iloc[-1])
    
    # 패턴 분석
    if analyze_patterns:
        peaks, troughs = find_peaks_and_troughs(df)

        is_db, neckline_db, is_potential_db = find_double_bottom(df, troughs, neckline_breakout=True)
        results['pattern_double_bottom'] = is_db
        results['pattern_double_bottom_potential'] = is_potential_db
        if is_db: results['pattern_description_db'] = f"이중바닥 패턴 형성 후 넥라인({neckline_db:.2f}원) 돌파 완료."
        elif is_potential_db: results['pattern_description_db'] = f"이중바닥 잠재적 형성. 넥라인({neckline_db:.2f}원) 돌파 필요."
        
        is_tb, neckline_tb, is_potential_tb = find_triple_bottom(df, troughs, neckline_breakout=True)
        results['pattern_triple_bottom'] = is_tb
        results['pattern_triple_bottom_potential'] = is_potential_tb
        if is_tb: results['pattern_description_tb'] = f"삼중바닥 패턴 형성 후 넥라인({neckline_tb:.2f}원) 돌파 완료."
        elif is_potential_tb: results['pattern_description_tb'] = f"삼중바닥 잠재적 형성. 넥라인({neckline_tb:.2f}원) 돌파 필요."

        is_ch, cup_high, handle_high, breakout_price_ch = find_cup_and_handle(df, peaks, troughs)
        results['pattern_cup_and_handle'] = is_ch
        if is_ch: results['pattern_description_ch'] = f"컵앤핸들 패턴 형성 후 저항선({handle_high:.2f}원) 돌파 완료."
                
    return results

def analyze_symbol(item, periods, analyze_patterns, exclude_negatives, pattern_type_filter):
    code = item.get("Code") or item.get("code")
    name = item.get("Name") or item.get("name")
    corp_code = item.get("DartCorpCode")
    path = DATA_DIR / f"{code}.parquet"
    if not path.exists(): return None
    
    try:
        df = pd.read_parquet(path)
        if len(df) < 50: return None 
        
        # 1. 기본적 분석 및 뉴스 가져오기
        fundamentals, headlines = get_fundamental_data(code)
        
        # 2. 악재 필터링
        if exclude_negatives:
            is_negative, reason = check_for_negatives(fundamentals, headlines, code, corp_code)
            if is_negative:
                logging.warning(f"[FILTERED] {name} ({code}): 악재로 제외됨. 이유: {reason}")
                return None
        
        # 3. 기술적 분석 및 패턴 감지
        analysis_results = check_ma_conditions(df, periods, analyze_patterns) 
        
        # 4. 패턴 필터링
        is_match = True
        if pattern_type_filter:
            # pattern_type_filter: 'double_bottom', 'triple_bottom', 'cup_and_handle', 'goldencross'
            if pattern_type_filter == 'goldencross':
                 is_match = analysis_results.get("goldencross_50_200_detected", False)
            elif pattern_type_filter == 'double_bottom':
                 is_match = analysis_results.get("pattern_double_bottom", False) or analysis_results.get("pattern_double_bottom_potential", False)
            elif pattern_type_filter == 'triple_bottom':
                 is_match = analysis_results.get("pattern_triple_bottom", False) or analysis_results.get("pattern_triple_bottom_potential", False)
            elif pattern_type_filter == 'cup_and_handle':
                 is_match = analysis_results.get("pattern_cup_and_handle", False)

        if not is_match: return None
        
        # 5. 결과 취합
        if analysis_results or fundamentals or headlines:
            combined_results = {
                "ticker": code,
                "name": name,
                "as_of_date": df.index.max().strftime("%Y-%m-%d"),
                "technical_conditions": analysis_results,
                "fundamentals": fundamentals,
                "recent_news_headlines": headlines
            }
            return combined_results
        return None
    except Exception as e:
        logging.error(f"[ERROR] {code} {name} 분석 실패: {e}\n{traceback.format_exc()}")
        return None

def run_analysis(workers, ma_periods_str, analyze_patterns, exclude_negatives, pattern_type_filter):
    logging.info(f"[LOG] 분석 시작 (패턴: {pattern_type_filter}, 악재 제외: {exclude_negatives})...")
    periods = [int(p.strip()) for p in ma_periods_str.split(',') if p.strip().isdigit()]
    
    # 패턴 필터가 있으면 패턴 분석 강제 활성화
    if pattern_type_filter: analyze_patterns = True 

    items = load_listing()
    results = []
    start_time = time.time()
    total_count = len(items)
    completed_count = 0

    with ThreadPoolExecutor(max_workers=workers) as ex:
        futs = [ex.submit(analyze_symbol, i, periods, analyze_patterns, exclude_negatives, pattern_type_filter) for i in items]
        
        for i, f in enumerate(as_completed(futs)):
            r = None
            try:
                r = f.result(timeout=30)
            except TimeoutError:
                logging.error(f"[ERROR] 분석 시간 초과: {items[i].get('Code')}")
            except Exception as e:
                 logging.error(f"[ERROR] 분석 중 예기치 않은 오류 발생: {e}")
            
            if r: results.append(r)
            completed_count += 1
            # (진행률 로깅 생략)
            
    elapsed = time.time() - start_time
    logging.info(f"[LOG] 총 소요: {elapsed:.2f}초")
    logging.info(f"[LOG] 분석 완료, {len(results)}개 종목 발견")
    safe_print_json({"results": results, "mode": "analyze"})

# =====================================================
# 7. 차트 생성 로직
# =====================================================
def generate_chart(symbol, ma_periods_str):
    """특정 종목의 주가 차트를 생성하여 Base64로 인코딩합니다."""
    try:
        periods = [int(p.strip()) for p in ma_periods_str.split(',') if p.strip().isdigit()]
        path = DATA_DIR / f"{symbol}.parquet"
        if not path.exists(): 
            safe_print_json({"error": f"데이터 파일 없음: {symbol}"})
            sys.exit(1)
            
        df = pd.read_parquet(path)
        stock_name = get_stock_name(symbol)
        if df.empty: 
            safe_print_json({"error": f"{stock_name} ({symbol}) 데이터 없음"})
            return
            
        # 최근 1년간의 데이터만 사용 (차트 시각성 확보)
        df = df.loc[df.index >= (datetime.now() - timedelta(days=365)).strftime("%Y-%m-%d")]
        if df.empty:
            safe_print